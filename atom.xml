<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dog Lai&#39;s Blog</title>
  
  <subtitle>Front-end development engineer</subtitle>
  <link href="https://lry61.cn/Joy-blog/atom.xml" rel="self"/>
  
  <link href="https://lry61.cn/Joy-blog/"/>
  <updated>2021-04-14T00:54:51.166Z</updated>
  <id>https://lry61.cn/Joy-blog/</id>
  
  <author>
    <name>Dog Lai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS数据类型与类型判断</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</id>
    <published>2021-04-12T12:46:32.000Z</published>
    <updated>2021-04-14T00:54:51.166Z</updated>
    
    <content type="html"><![CDATA[<p>JS数据类型基础知识回顾</p><span id="more"></span><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><p>JavaScript数据类型分为“基本数据类型”和“引用数据类型”。到目前为止，基本数据类型共有7种，引用数据类型1种。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>number</li><li>string</li><li>boolean</li><li>undefined</li><li>null</li><li>symbol(唯一标识符)</li><li>bigint(任意大整数)</li></ul><p>基本数据类型的值是不可变的，前面5种类型日常使用的比较频繁，不再过多记录，这里记录下ES6以后新增的symbol与bigint。</p><h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>symbol是ES6新增的一种基本数据类型，是一种唯一标识符。</p><ol><li><p>定义: <code>let sml = Symbol('symbol')</code></p></li><li><p>特性:</p></li></ol><ul><li><p>唯一性<br>通过symbol声明的两个变量，即使是同一个值也不相等。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let sml2 = Symbol('1');</span><br><span class="line">console.log(sml1 === sml2); // false</span><br></pre></td></tr></tbody></table></figure></li><li><p>可访问性<br>symbol声明的变量，无法通过for…in、object.keys()访问</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let obj = {</span><br><span class="line">  [sml1]: '2'</span><br><span class="line">};</span><br><span class="line">for(let s in obj) {</span><br><span class="line">  console.log(obj[s]); // undefined</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li>常用方法</li></ol><ul><li><p>Object.getOwnPropertySymbols(obj)<br>返回一个数组，成员是当前对象用作属性名的symbol值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let obj = {</span><br><span class="line">  [sml1]: '2'</span><br><span class="line">};</span><br><span class="line">let arr = Object.getOwnPropertySymbols(obj);</span><br><span class="line">console.log(arr); // [Symbol(1)]</span><br><span class="line">console.log(obj[arr[0]]); // 2</span><br></pre></td></tr></tbody></table></figure></li><li><p>Symbol.for()<br>使相同参数变量的symbol值相等</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol.for('1');</span><br><span class="line">let sml2 = Symbol.for('1');</span><br><span class="line">console.log(sml1 === sml2); // true</span><br></pre></td></tr></tbody></table></figure></li><li><p>Symbol.keyFor()<br>获取参数值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol.for('1');</span><br><span class="line">console.log(Symbol.keyFor(sml1)); // 1</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h4><p>在基本数据类型中，整数通常由number类型表示，但是number类型只能表示某个范围内[-(2^53 - 1) ~ (2^53 - 1)]的整数，超出会失去精度;而bigint则可以表示任意大的整数</p><ol><li>使用方法</li></ol><ul><li><p>末尾加 n</p></li><li><p>构造函数BigInt()</p></li></ul><ol start="2"><li>注意</li></ol><ul><li><p>bigint不能与number一起使用</p></li><li><p>bigint不能与“+”号一起使用</p></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>  引用数据类型object的值是可变的，通常赋值的引用类型，其指向相同的堆内存。<br>  object包括了数值Array、函数Function、特殊的正则RegExp和时间Date</p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof返回一个表示数据类型的字符串</p><ul><li><p>对于基本数据类型<br>返回相应的数据类型，<strong>null除外</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof 1; // number √</span><br><span class="line">typeof '1'; // string √</span><br><span class="line">typeof true; // boolean √</span><br><span class="line">typeof undefined; //undefined √</span><br><span class="line">typeof null; // object ×</span><br><span class="line">typeof NaN; // number √(NaN据说是number类型的...好奇.jpg)</span><br><span class="line">typeof Symbol(); // symbol √</span><br><span class="line">typeof 9007199254740999n; // bigint √</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于引用数据类型<br>返回object，<strong>function除外</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof new Function(); // function √</span><br><span class="line">typeof []; // object ×</span><br><span class="line">typeof new Date(); // object ×</span><br><span class="line">typeof new RegExp(); // object ×</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof用来检测构造函数的prototype属性是否出现在某个实例对象的原型链上，存在返回true，否则返回false。<strong>instanceof是相对引用类型的，基本数据类型不适用</strong></p><pre><code><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array; // true √</span><br><span class="line">new Date() instanceof Date; // true √</span><br><span class="line">'1' instanceof String; // false ×</span><br><span class="line">null instanceof null; // 报错，无法检测</span><br><span class="line">undefined instanceof undefined; //报错，无法检测</span><br></pre></td></tr></tbody></table></figure></code></pre><p>值得注意的是，对象原型链最终都指向了Object，即 <code>Array.prototype._proto_ = Object.prototype</code>。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor与instanceof类似，可能在重写过程中把之前的constructor覆盖掉，导致结果不准确。</p><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p><strong>最常用最全能的方法</strong>。MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">有段描述</a>：</p><blockquote><p>每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型</p></blockquote><pre><code><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call('1'); // [object String]</span><br><span class="line">Object.prototype.toString.call(1); // [object Number]</span><br><span class="line">Object.prototype.toString.call(true); // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(undefined); // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(null); // [object Null]</span><br><span class="line">Object.prototype.toString.call(new Function()); // [object Function]</span><br><span class="line">Object.prototype.toString.call(new Date()); // [object Date]</span><br><span class="line">Object.prototype.toString.call([]); // [object Array]</span><br><span class="line">Object.prototype.toString.call(new RegExp()); // [object RegExp]</span><br></pre></td></tr></tbody></table></figure></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;JS数据类型基础知识回顾&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to Dog Lai&#39;s Blog</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/07/welcome/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/07/welcome/</id>
    <published>2021-04-07T01:13:25.653Z</published>
    <updated>2021-04-09T13:27:00.342Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Dog Lai’s Blog</p><span id="more"></span><p>之前在网上查资料时，经常能看到别人高大上的Blog，脑子里都有个Blog 2.0的想法，刚好这段时间项目期不紧，就想着把之前的Blog升级下，发布一个 Blog 2.0-beat版（花里胡哨的版本）</p><h3 id="Blog-2-0-beat奇思妙想"><a href="#Blog-2-0-beat奇思妙想" class="headerlink" title="Blog 2.0-beat奇思妙想"></a>Blog 2.0-beat奇思妙想</h3><p>对我而言，我希望2.0版本的博客不单单只是一个博客，它更像微信一样，是一个小型社交平台。我不仅可以在这里记录项目中遇到的问题难点，还能够分享生活中的点点滴滴，与别人交流、发朋友圈、上传相册、放置简历…<br>正如我想的那样，2.0-beat coming！</p><h3 id="artitalk-圈子"><a href="#artitalk-圈子" class="headerlink" title="artitalk 圈子"></a>artitalk 圈子</h3><p>对我而言，有时候想在朋友圈发一些自己的想法有诸多不便，我迫切的需要一个平台表达我的某些想法意见；基于此，artitalk 圈子运营而生，它满足我目前的所有幻想，感情树洞、idea…对我意义重大!</p><h3 id="photos-相册"><a href="#photos-相册" class="headerlink" title="photos 相册"></a>photos 相册</h3><p>我希望可以将自己的相册移植到博客中，正好gitHub仓库可以作为图床使用。</p><blockquote><p>我希望后面可以使用时间线来布局我的相册，并且能够配上简短的文字说明<br>这在后面会慢慢考虑功能的实现</p></blockquote><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>如果你喜欢我的博客，请给我个Star吧~</p><blockquote><p>欢迎留言<br>欢迎技术交流<br>欢迎谈论博客优化</p></blockquote><p>感谢你的阅读 Thanks♪(･ω･)ﾉ</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to Dog Lai’s Blog&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dog Lai&#39;s Blog</title>
  
  <subtitle>Front-end development engineer</subtitle>
  <link href="https://lry61.cn/Joy-blog/atom.xml" rel="self"/>
  
  <link href="https://lry61.cn/Joy-blog/"/>
  <updated>2021-04-15T11:28:04.438Z</updated>
  <id>https://lry61.cn/Joy-blog/</id>
  
  <author>
    <name>Dog Lai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>水平垂直居中问题</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/15/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/15/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-15T11:28:04.000Z</published>
    <updated>2021-04-15T11:28:04.438Z</updated>
    
    <content type="html"><![CDATA[<p>css中常用的水平垂直居中记录</p><span id="more"></span><p>项目开发中我们经常会遇到盒子的水平垂直居中问题，定宽高的方式有很多，这里不再记录，主要记录下在不定宽高情况下的实现方式。</p><p>下面用到的盒子如下：</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="parent"&gt;</span><br><span class="line">  &lt;div class="son"&gt;测试水平垂直居中&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="flex-margin"><a href="#flex-margin" class="headerlink" title="flex + margin"></a>flex + margin</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: flex;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  margin: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h2><p>常用于图片的居中显示</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h2><p>利用表格布局方式实现</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: table-cell;</span><br><span class="line">  text-align: center;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: grid;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  align-self: center;</span><br><span class="line">  justify-self: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="absolute-四个方向值相等"><a href="#absolute-四个方向值相等" class="headerlink" title="absolute + 四个方向值相等"></a>absolute + 四个方向值相等</h2><p>这种方式需要设置子元素的宽高、并且需要设置”margin: auto”</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  width: xxx;</span><br><span class="line">  height: xxx;</span><br><span class="line">  margin: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="after伪元素"><a href="#after伪元素" class="headerlink" title="after伪元素"></a>after伪元素</h2><p>子元素display需要设置为”inline-block”才生效</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  text-align: center;</span><br><span class="line">}</span><br><span class="line">.parent::after {</span><br><span class="line">  content: '';</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  height: 100%;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="before伪元素"><a href="#before伪元素" class="headerlink" title="before伪元素"></a>before伪元素</h2><p>“font-size: 0” 可以消除标签之间的间隙。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 0;</span><br><span class="line">}</span><br><span class="line">.parent::before {</span><br><span class="line">  content: '';</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  height: 100%;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;css中常用的水平垂直居中记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Css" scheme="https://lry61.cn/Joy-blog/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>BFC记录</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/15/BFC%E8%AE%B0%E5%BD%95/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/15/BFC%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-15T07:35:01.000Z</published>
    <updated>2021-04-15T07:35:01.828Z</updated>
    
    <content type="html"><![CDATA[<p>什么是BFC？原理？使用场景？</p><span id="more"></span><h2 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h2><p>BFC(Block formatting context)直译为“块级格式化上下文”，它是一个独立的渲染区域，规定了内部如何布局，并且与区域外部毫不相关。</p><blockquote><p>通俗一点，创建了BFC的元素就是个独立的盒子，里面子元素的布局不会影响外面元素。</p></blockquote><h2 id="BCF原理"><a href="#BCF原理" class="headerlink" title="BCF原理"></a>BCF原理</h2><ol><li>内部的Box在垂直方向一个接一个的放置。</li><li>Box垂直方向距离由margin决定，属于同一个BFC的两个相邻Box的margin会重叠。</li><li>每个元素的margin box左边，与包含块border box的左边相接触，即使存在浮动也是如此。</li><li>BFC区域不与float box重叠。</li><li>BFC里面的子元素不会影响外面的元素。</li><li>计算BFC高度时，浮动元素也参与计算。</li></ol><h2 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h2><p>满足以下任一条件即可创建BFC:</p><ol><li>根元素</li><li>float属性不是none</li><li>position不为static、relative</li><li>overflow不为visible</li><li>display为inline-block、table-cell、table-caption、flex、line-flex…</li></ol><h2 id="BFC使用场景"><a href="#BFC使用场景" class="headerlink" title="BFC使用场景"></a>BFC使用场景</h2><ol><li>防止margin重叠</li><li>清除内部浮动(解决高度塌陷)</li><li>自适应两栏布局</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是BFC？原理？使用场景？&lt;/p&gt;</summary>
    
    
    
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Css" scheme="https://lry61.cn/Joy-blog/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>call、apply、bind的区别与实现</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/14/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/14/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-14T07:49:27.000Z</published>
    <updated>2021-04-14T07:49:27.700Z</updated>
    
    <content type="html"><![CDATA[<p>了解call、apply、bind异同及实现原理</p><span id="more"></span><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ul><li>call、apply、bind都是函数Function原型链上的方法</li><li>都是用来改变函数执行时内部的this指向</li><li>都可以接收两个或多个参数，第一个为改变后的this指向，后面为可选参数</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>call、apply调用会立即返回结果，bind不会立即调用，而是返回一个新函数</li><li>call的可选参数为参数列表，apply的可选参数为数组或类数组对象</li></ul><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>func.call(thisArg, arg1, arg2, ...)</code></p><ul><li>thisArg: 可选。如果为null或undefined，则指向window</li><li>arg1, arg2,…: 参数列表</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>判断数据类型 <code>Object.prototype.toString.call()</code></p></li><li><p>类数组借用数组方法 <code>Array.prototype.push.call()</code>、<code>[].slice.call(arguments)</code></p></li></ol><h3 id="手写实现call"><a href="#手写实现call" class="headerlink" title="手写实现call"></a>手写实现call</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.iCall = function(context) {</span><br><span class="line">  if(context === null || context === undefined) {</span><br><span class="line">    // 指定null或undefined的this值指向window</span><br><span class="line">    context = window;</span><br><span class="line">  } else {</span><br><span class="line">    // 值为原始值(number、string、boolean)的this会指向该原始值的实例对象</span><br><span class="line">    context = Object(context);</span><br><span class="line">  }</span><br><span class="line">  // 函数的this指向隐式绑定到context上</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 取出执行函数的剩余参数列表</span><br><span class="line">  let args = [...arguments].slice(1);</span><br><span class="line">  let result = context.fn(...args); // 执行函数</span><br><span class="line">  delete context.fn; // 删除上下文属性，避免内存泄漏</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><code>func.apply(thisArg, [arg1, arg2, ...])</code></p><ul><li>thisArg: 可选。如果为null或undefined，则指向window</li><li>arg1, arg2, …: 数组参数列表</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>获取数组最大最小值 <code>Math.max.apply(Math, arr)</code>、<code>Math.min(Math, arr)</code></li></ol><h3 id="手写实现apply"><a href="#手写实现apply" class="headerlink" title="手写实现apply"></a>手写实现apply</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function.prototype.iApply = function(context) {</span><br><span class="line">  if(context === null || context === undefined) {</span><br><span class="line">    context = window;</span><br><span class="line">  } else {</span><br><span class="line">    context = Object(context);</span><br><span class="line">  }</span><br><span class="line">  context.fn = this;</span><br><span class="line">  let result;</span><br><span class="line">  if(arguments[1]) { // 判断是否有剩余参数，如果有则带参执行</span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  } else {</span><br><span class="line">    result = context.fn();</span><br><span class="line">  }</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><code>func.bind(thisArg, arg1, arg2, ...)</code></p><ul><li>thisArg: 传递给目标函数的值。</li><li>arg1, arg2, …: 参数列表。当目标函数被调用后，放在目标函数参数列表中</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>保存函数参数</li></ul><p>  来看一个经典的面试题</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i++) {</span><br><span class="line">  setTimeout(function test() {</span><br><span class="line">    console.log(i); // 依次输出: 6 6 6 6 6</span><br><span class="line">  }, i*1000);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  造成这个现象的原因是在setTimeout异步执行时，i已经变成6了。<br>  如果要让它依次输出1,2,3,4,5，有多种解决办法：</p><ol><li>闭包</li></ol>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i++) {</span><br><span class="line">  (function(i) {</span><br><span class="line">    setTimeout(function() {</span><br><span class="line">      console.log(i); // 依次输出: 1 2 3 4 5</span><br><span class="line">    }, i*1000);</span><br><span class="line">  }(i))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>bind绑定</li></ol>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i++) {</span><br><span class="line">  setTimeout(function(i) {</span><br><span class="line">    console.log(i); // 依次输出: 1 2 3 4 5</span><br><span class="line">  }.bind(null, i), i*1000);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  实际上这里也是返回了一个闭包，它保存了函数的this指向，初始参数，每次i的变化都会被bind的闭包存起来。</p><ul><li>解决回调函数this丢失</li></ul><h3 id="手写实现bind-划重点"><a href="#手写实现bind-划重点" class="headerlink" title="手写实现bind(划重点)"></a>手写实现bind(划重点)</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function.prototype.iBind = function(objThis, ...args) {</span><br><span class="line">  let thisFn = this; //存储源函数及args</span><br><span class="line">  let fToBind = function() {</span><br><span class="line">    // 判断this是否是fToBind实例，即返回的fToBind是否通过new调用</span><br><span class="line">    const isNew = this instanceof fToBind;</span><br><span class="line">    // new调用就绑定到this，否则绑定到传入的objThis上</span><br><span class="line">    const context = isNew ? this : Object(objThis);</span><br><span class="line">    // apply调用源函数绑定this并传参，返回执行结果</span><br><span class="line">    return thisFn.apply(context, args);</span><br><span class="line">  };</span><br><span class="line">  // 复制源函数的prototype给fToBind</span><br><span class="line">  fToBind.prototype = Object.create(thisFn.prototype);</span><br><span class="line">  return fToBind; // 返回拷贝的函数</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解call、apply、bind异同及实现原理&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JS数据类型与类型判断</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</id>
    <published>2021-04-12T12:46:32.000Z</published>
    <updated>2021-04-14T00:54:51.166Z</updated>
    
    <content type="html"><![CDATA[<p>JS数据类型基础知识回顾</p><span id="more"></span><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><p>JavaScript数据类型分为“基本数据类型”和“引用数据类型”。到目前为止，基本数据类型共有7种，引用数据类型1种。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>number</li><li>string</li><li>boolean</li><li>undefined</li><li>null</li><li>symbol(唯一标识符)</li><li>bigint(任意大整数)</li></ul><p>基本数据类型的值是不可变的，前面5种类型日常使用的比较频繁，不再过多记录，这里记录下ES6以后新增的symbol与bigint。</p><h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>symbol是ES6新增的一种基本数据类型，是一种唯一标识符。</p><ol><li><p>定义: <code>let sml = Symbol('symbol')</code></p></li><li><p>特性:</p></li></ol><ul><li><p>唯一性<br>通过symbol声明的两个变量，即使是同一个值也不相等。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let sml2 = Symbol('1');</span><br><span class="line">console.log(sml1 === sml2); // false</span><br></pre></td></tr></tbody></table></figure></li><li><p>可访问性<br>symbol声明的变量，无法通过for…in、object.keys()访问</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let obj = {</span><br><span class="line">  [sml1]: '2'</span><br><span class="line">};</span><br><span class="line">for(let s in obj) {</span><br><span class="line">  console.log(obj[s]); // undefined</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li>常用方法</li></ol><ul><li><p>Object.getOwnPropertySymbols(obj)<br>返回一个数组，成员是当前对象用作属性名的symbol值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let obj = {</span><br><span class="line">  [sml1]: '2'</span><br><span class="line">};</span><br><span class="line">let arr = Object.getOwnPropertySymbols(obj);</span><br><span class="line">console.log(arr); // [Symbol(1)]</span><br><span class="line">console.log(obj[arr[0]]); // 2</span><br></pre></td></tr></tbody></table></figure></li><li><p>Symbol.for()<br>使相同参数变量的symbol值相等</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol.for('1');</span><br><span class="line">let sml2 = Symbol.for('1');</span><br><span class="line">console.log(sml1 === sml2); // true</span><br></pre></td></tr></tbody></table></figure></li><li><p>Symbol.keyFor()<br>获取参数值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol.for('1');</span><br><span class="line">console.log(Symbol.keyFor(sml1)); // 1</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h4><p>在基本数据类型中，整数通常由number类型表示，但是number类型只能表示某个范围内[-(2^53 - 1) ~ (2^53 - 1)]的整数，超出会失去精度;而bigint则可以表示任意大的整数</p><ol><li>使用方法</li></ol><ul><li><p>末尾加 n</p></li><li><p>构造函数BigInt()</p></li></ul><ol start="2"><li>注意</li></ol><ul><li><p>bigint不能与number一起使用</p></li><li><p>bigint不能与“+”号一起使用</p></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>  引用数据类型object的值是可变的，通常赋值的引用类型，其指向相同的堆内存。<br>  object包括了数值Array、函数Function、特殊的正则RegExp和时间Date</p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof返回一个表示数据类型的字符串</p><ul><li><p>对于基本数据类型<br>返回相应的数据类型，<strong>null除外</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof 1; // number √</span><br><span class="line">typeof '1'; // string √</span><br><span class="line">typeof true; // boolean √</span><br><span class="line">typeof undefined; //undefined √</span><br><span class="line">typeof null; // object ×</span><br><span class="line">typeof NaN; // number √(NaN据说是number类型的...好奇.jpg)</span><br><span class="line">typeof Symbol(); // symbol √</span><br><span class="line">typeof 9007199254740999n; // bigint √</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于引用数据类型<br>返回object，<strong>function除外</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof new Function(); // function √</span><br><span class="line">typeof []; // object ×</span><br><span class="line">typeof new Date(); // object ×</span><br><span class="line">typeof new RegExp(); // object ×</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof用来检测构造函数的prototype属性是否出现在某个实例对象的原型链上，存在返回true，否则返回false。<strong>instanceof是相对引用类型的，基本数据类型不适用</strong></p><pre><code><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array; // true √</span><br><span class="line">new Date() instanceof Date; // true √</span><br><span class="line">'1' instanceof String; // false ×</span><br><span class="line">null instanceof null; // 报错，无法检测</span><br><span class="line">undefined instanceof undefined; //报错，无法检测</span><br></pre></td></tr></tbody></table></figure></code></pre><p>值得注意的是，对象原型链最终都指向了Object，即 <code>Array.prototype._proto_ = Object.prototype</code>。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor与instanceof类似，可能在重写过程中把之前的constructor覆盖掉，导致结果不准确。</p><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p><strong>最常用最全能的方法</strong>。MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">有段描述</a>：</p><blockquote><p>每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型</p></blockquote><pre><code><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call('1'); // [object String]</span><br><span class="line">Object.prototype.toString.call(1); // [object Number]</span><br><span class="line">Object.prototype.toString.call(true); // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(undefined); // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(null); // [object Null]</span><br><span class="line">Object.prototype.toString.call(new Function()); // [object Function]</span><br><span class="line">Object.prototype.toString.call(new Date()); // [object Date]</span><br><span class="line">Object.prototype.toString.call([]); // [object Array]</span><br><span class="line">Object.prototype.toString.call(new RegExp()); // [object RegExp]</span><br></pre></td></tr></tbody></table></figure></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;JS数据类型基础知识回顾&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to Dog Lai&#39;s Blog</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/07/welcome/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/07/welcome/</id>
    <published>2021-04-07T01:13:25.653Z</published>
    <updated>2021-04-09T13:27:00.342Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Dog Lai’s Blog</p><span id="more"></span><p>之前在网上查资料时，经常能看到别人高大上的Blog，脑子里都有个Blog 2.0的想法，刚好这段时间项目期不紧，就想着把之前的Blog升级下，发布一个 Blog 2.0-beat版（花里胡哨的版本）</p><h3 id="Blog-2-0-beat奇思妙想"><a href="#Blog-2-0-beat奇思妙想" class="headerlink" title="Blog 2.0-beat奇思妙想"></a>Blog 2.0-beat奇思妙想</h3><p>对我而言，我希望2.0版本的博客不单单只是一个博客，它更像微信一样，是一个小型社交平台。我不仅可以在这里记录项目中遇到的问题难点，还能够分享生活中的点点滴滴，与别人交流、发朋友圈、上传相册、放置简历…<br>正如我想的那样，2.0-beat coming！</p><h3 id="artitalk-圈子"><a href="#artitalk-圈子" class="headerlink" title="artitalk 圈子"></a>artitalk 圈子</h3><p>对我而言，有时候想在朋友圈发一些自己的想法有诸多不便，我迫切的需要一个平台表达我的某些想法意见；基于此，artitalk 圈子运营而生，它满足我目前的所有幻想，感情树洞、idea…对我意义重大!</p><h3 id="photos-相册"><a href="#photos-相册" class="headerlink" title="photos 相册"></a>photos 相册</h3><p>我希望可以将自己的相册移植到博客中，正好gitHub仓库可以作为图床使用。</p><blockquote><p>我希望后面可以使用时间线来布局我的相册，并且能够配上简短的文字说明<br>这在后面会慢慢考虑功能的实现</p></blockquote><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>如果你喜欢我的博客，请给我个Star吧~</p><blockquote><p>欢迎留言<br>欢迎技术交流<br>欢迎谈论博客优化</p></blockquote><p>感谢你的阅读 Thanks♪(･ω･)ﾉ</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to Dog Lai’s Blog&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

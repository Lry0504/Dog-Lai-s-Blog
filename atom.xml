<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dog Lai&#39;s Blog</title>
  
  <subtitle>Front-end development engineer</subtitle>
  <link href="https://lry61.cn/Joy-blog/atom.xml" rel="self"/>
  
  <link href="https://lry61.cn/Joy-blog/"/>
  <updated>2021-04-26T02:27:44.984Z</updated>
  <id>https://lry61.cn/Joy-blog/</id>
  
  <author>
    <name>Dog Lai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS数组去重</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/26/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/26/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</id>
    <published>2021-04-26T02:27:44.000Z</published>
    <updated>2021-04-26T02:27:44.984Z</updated>
    
    <content type="html"><![CDATA[<p>JS数组去重的几种实现方式</p><span id="more"></span><p>JS数组去重问题也是近几年来面试手写的高频问题，这里简单记录下不同的实现方式及无法去重的情况。<br>下面数组应用于每个实现方式中</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">  1, 1, true, "true", "false",</span><br><span class="line">  false, NaN, "NaN", null, undefined,</span><br><span class="line">  15, undefined, 15, {}, 0,</span><br><span class="line">  "a", {}, 0, "a", NaN,</span><br><span class="line">  null, undefined</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h2 id="双层循环"><a href="#双层循环" class="headerlink" title="双层循环"></a>双层循环</h2><blockquote><p>实现思路:<br>利用双层for循环嵌套，然后用splice去重<br>当循环数组第一层的值与第二层的值相同的时候，删除第二层相对应的值。</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) {</span><br><span class="line">    for(let j = i + 1; j &lt; arr.length; j++) {</span><br><span class="line">      if(arr[i] === arr[j]) {</span><br><span class="line">        arr.splice(j, 1);</span><br><span class="line">        j--;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return arr;</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/%E5%8F%8C%E5%B1%82%E5%BE%AA%E7%8E%AF.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果中可以看出：双层循环的方法<strong>无法去重NaN和{}</strong></p><h2 id="indexOf循环"><a href="#indexOf循环" class="headerlink" title="indexOf循环"></a>indexOf循环</h2><blockquote><p>实现思路:<br>利用indexOf循环数组，判断结果数组res中是否存在当前元素。如果存在，则跳过；否则把当前元素添加到结果数组res中。</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  let res = [];</span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) {</span><br><span class="line">    if(res.indexOf(arr[i]) === -1) {</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return res;</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/indexOf.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：indexOf循环的方法<strong>无法去重NaN和{}</strong></p><h2 id="排序后去重"><a href="#排序后去重" class="headerlink" title="排序后去重"></a>排序后去重</h2><blockquote><p>实现思路:<br>将数组用sort排序后，相同的值便会在相邻位置。<br>结果数组先存入数组第一个值，然后从第二个值开始，判断与前一个值是否相同。如果相同，则说明重复；否则放进结果数组res中。</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  arr = arr.sort();</span><br><span class="line">  let res = [arr[0]];</span><br><span class="line">  for(let i = 1; i &lt; arr.length; i++) {</span><br><span class="line">    if(arr[i] !== arr[i - 1]) {</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return res;</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/%E6%8E%92%E5%BA%8F%E5%90%8E%E5%8E%BB%E9%87%8D.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：排序后去重的方法<strong>无法去重NaN和{}</strong></p><h2 id="利用includes"><a href="#利用includes" class="headerlink" title="利用includes"></a>利用includes</h2><blockquote><p>实现思路:<br>判断结果数组中是否包含某个值；如果包含，则跳过；否则放进结果数组res中</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  let res = [];</span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) {</span><br><span class="line">    if(!res.includes(arr[i])) {</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return res;</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/includes.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：includes的方法<strong>无法去重{}</strong></p><h2 id="利用filter"><a href="#利用filter" class="headerlink" title="利用filter"></a>利用filter</h2><blockquote><p>实现思路:<br>判断数组中当前元素的第一个索引是否是filter中当前的索引值</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  return arr.filter((item, index, arr) =&gt; {</span><br><span class="line">    return arr.indexOf(item) === index;</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/filter.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：filter的方法<strong>无法去重{}，并且把NaN删掉了</strong></p><h2 id="reduce-includes"><a href="#reduce-includes" class="headerlink" title="reduce + includes"></a>reduce + includes</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  return arr.reduce((acc, cur) =&gt;</span><br><span class="line">    acc.includes(cur) ? acc : [...acc, cur], []</span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/reduce%2Bincludes.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：reduce+includes的方法<strong>无法去重{}</strong></p><h2 id="利用Set"><a href="#利用Set" class="headerlink" title="利用Set"></a>利用Set</h2><blockquote><p>实现思路:<br>Set对象是值的集合，你可以按照插入的顺序迭代元素。Set对象中的元素只会出现一次，即Set中的元素是唯一的</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  return [...new Set(arr)];</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/Set.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：Set的方法<strong>无法去重{}</strong></p><h2 id="利用hasOwnProperty"><a href="#利用hasOwnProperty" class="headerlink" title="利用hasOwnProperty"></a>利用hasOwnProperty</h2><p>hasOwnProperty方法会返回一个布尔值，指示对象本身属性中是否具有指定的属性（是否有指定的值）。此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。</p><blockquote><p>实现思路:<br>利用一个空对象obj，把数组的值存成obj对象的key值，如obj[arr[item1]] = true，判断另一个值obj[arr[item2]]是否存在，如果存在，则是相同的值</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  let obj = {};</span><br><span class="line">  return arr.filter((item, index, arr) =&gt; {</span><br><span class="line">    return obj.hasOwnProperty(item) ? false : (obj[item] = true)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/hasOwnProperty_1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从结果中可以看到，这个方法存在一些问题：true与”true”是不同的，但是<strong>Object[true]和Object[“true”]却是同一个引用(对象key值只能是字符串)</strong><br>解决办法：使用<code>typeof item + item</code>拼接成字符串作为key值</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  let obj = {};</span><br><span class="line">  return arr.filter((item, index, arr) =&gt; {</span><br><span class="line">    return obj.hasOwnProperty(typeof item + item) ?</span><br><span class="line">    false : (obj[typeof item + item] = true)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><p>我们知道，如果你数组中存在对象时，如{value: 1}，typeof item + item的结果都是object[object Object]<br>解决办法：使用JSON.stringify()将对象序列化来避免相同的键值</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  let obj = {};</span><br><span class="line">  return arr.filter((item, index, arr) =&gt; {</span><br><span class="line">    return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ?</span><br><span class="line">    false : (obj[typeof item + JSON.stringify(item)] = true)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/hasOwnProperty_2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种方式可以满足所有的条件去重。</p><h2 id="利用Map"><a href="#利用Map" class="headerlink" title="利用Map"></a>利用Map</h2><blockquote><p>实现思路:<br>创建一个空的Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。<br>由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  let map = new Map();</span><br><span class="line">  let array = [];</span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) {</span><br><span class="line">    if(map.has(arr[i])) { // 如果存在该key值</span><br><span class="line">      map.set(arr[i], true);</span><br><span class="line">    } else {</span><br><span class="line">      map.set(arr[i], false);</span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return array;</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/Map.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：Map的方法<strong>无法去重{}</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) {</span><br><span class="line">  arr.sort(function(a, b) {</span><br><span class="line">    return a - b;</span><br><span class="line">  });</span><br><span class="line">  function loop(index) {</span><br><span class="line">    if(index &gt;= 1) {</span><br><span class="line">      if(arr[index] === arr[index - 1]) {</span><br><span class="line">        arr.splice(index, 1);</span><br><span class="line">      }</span><br><span class="line">      loop(index - 1);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  loop(arr.length - 1);</span><br><span class="line">  return arr;</span><br><span class="line">}</span><br><span class="line">console.log(unique(arr));</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/loop%E9%80%92%E5%BD%92.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上面结果可以看出：递归循环的方法<strong>无法去重NaN、null、0、”a”和{}</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JS数组去重的几种实现方式&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Array常用api梳理二</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/23/Array%E5%B8%B8%E7%94%A8api%E6%A2%B3%E7%90%86%E4%BA%8C/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/23/Array%E5%B8%B8%E7%94%A8api%E6%A2%B3%E7%90%86%E4%BA%8C/</id>
    <published>2021-04-23T11:50:46.000Z</published>
    <updated>2021-04-23T11:50:47.295Z</updated>
    
    <content type="html"><![CDATA[<p>梳理Array常用的api</p><span id="more"></span><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>splice方法用于删除原数组的部分成员，并可以在删除的位置插入新的数组成员，返回值是被删除的元素。<strong>会改变原数组</strong><br><code>[].splice(start, count, addItem1, addItem2, ...)</code><br>splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有参数，则表示要插入数组的新元素。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5];</span><br><span class="line">arr.splice(3,2); // [4,5]</span><br><span class="line">arr; // [1,2,3]</span><br><span class="line">arr.splice(0,1,4,5);</span><br><span class="line">arr; // [4,5,2,3]</span><br></pre></td></tr></tbody></table></figure><p>如果只提供第一个参数，等同于将原数组在指定位置拆分为两个数组。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort方法用于对数组进行排序，默认按照字典顺序(值会先被转成字符串，再按照字典顺序排列)排序。<strong>会改变原数组</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">["d","b","c","a"].sort(); // ["a","b","c","d"]</span><br><span class="line">[2,3,4,1].sort(); // [1,2,3,4]</span><br><span class="line">[11,101].sort(); // [101,11]</span><br></pre></td></tr></tbody></table></figure><p>如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[10111, 1101, 111].sort(function(a, b) {</span><br><span class="line">  return a - b;</span><br><span class="line">}); // [111, 1101, 10111]</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，sort的参数函数接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，则表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个前面。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map方法将所有的数组成员依次传入参数函数，然后把每一次的执行结果组成一个新的数组返回。<strong>原数组不变</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.map(n =&gt; n+1); // [2,3,4]</span><br><span class="line">arr; // [1,2,3]</span><br></pre></td></tr></tbody></table></figure><p>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置、数组本身。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].map((item, index, arr) =&gt; item * index); // [0, 2, 6]</span><br></pre></td></tr></tbody></table></figure><p>map方法还可以接受第二个参数，用来绑定回调函数内部的this指向。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">[1,2].map(function(e) {</span><br><span class="line">  return this[e];</span><br><span class="line">}, arr); // [2,3]</span><br></pre></td></tr></tbody></table></figure><p>如果数组中有空位，map方法的回调函数在这个位置不会执行，会跳过数组空位。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f = function(n) { return "a"; };</span><br><span class="line">[1, undefined, 2].map(f); // ["a", "a", "a"]</span><br><span class="line">[1, null, 2].map(f); // ["a", "a", "a"]</span><br><span class="line">[1, , 2].map(f); // ["a", , "a"]</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，map方法不会跳过undefined和null，但是会跳过空位。</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>forEach方法与map方法类似，也是对数组的所有成员依次执行参数函数。但是，<em>forEach方法不返回值，只是用来操作数据</em>。其他使用方式与map基本一样，不再重复。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter方法用于过滤数组成员，满足条件的成员组成一个新的数组返回。<br>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新的数组返回。<strong>原数组不变</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].filter(function(item) {</span><br><span class="line">  return item &gt; 3;</span><br><span class="line">}); // [4,5]</span><br></pre></td></tr></tbody></table></figure><p>filter方法的参数函数同样可以接受三个参数：当前成员、当前位置、原数组。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].filter(function(item, index, arr) {</span><br><span class="line">  return item % 2 === 0;</span><br><span class="line">}); // [2,4]</span><br></pre></td></tr></tbody></table></figure><p>filter方法也可以接受第二个参数，用来绑定参数函数内部的this指向。</p><h2 id="some与every"><a href="#some与every" class="headerlink" title="some与every"></a>some与every</h2><p>这两个方法类似断言，返回一个boolean值，表示判断数组成员是否符合某种条件。他们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置、原数组，返回一个boolean值。<br>some方法是<em>只要一个成员返回true，则整个some方法的返回值都是true</em>。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5];</span><br><span class="line">arr.some(function(item, index, arr) {</span><br><span class="line">  return item &gt;= 3;</span><br><span class="line">}); // true</span><br></pre></td></tr></tbody></table></figure><p>every方法是<em>所有成员的返回值都是true，结果才是true</em></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5];</span><br><span class="line">arr.every(function(item, index, arr) {</span><br><span class="line">  return item &gt;= 3;</span><br><span class="line">}); // false</span><br></pre></td></tr></tbody></table></figure><p>**注意!!!**对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isEven(x) { return x % 2 === 0 };</span><br><span class="line">[].some(isEven); // false</span><br><span class="line">[].every(isEven); // true</span><br></pre></td></tr></tbody></table></figure><p>some与every也可以接受第二个参数用来绑定参数函数内部的this指向。</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce方法依次处理数组中的每一个成员，最终累计为一个值。<br>reduce方法第一个参数是一个函数，该函数接受四个参数：</p><ol><li>累积变量：默认为数组第一个成员；</li><li>当前变量：默认为数组第二个成员；</li><li>当前位置：从0开始；</li><li>原数组</li></ol><p>这四个参数中，只有前两个是必须的，后两个可选。<br>如果要对累积变量指定初值，可以把它放在reduce方法的第二个参数上。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5].reduce(function(a, b) {</span><br><span class="line">  return a + b;</span><br><span class="line">}, 10); // 25</span><br></pre></td></tr></tbody></table></figure><p>上面代码指定参数a的初值为10，所有数组从10开始累加，最终结果为25。此时，b是从数组的第一个成员开始遍历。</p><h2 id="indexOf与lastIndexOf"><a href="#indexOf与lastIndexOf" class="headerlink" title="indexOf与lastIndexOf"></a>indexOf与lastIndexOf</h2><p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5];</span><br><span class="line">arr.indexOf(2); // 1</span><br><span class="line">arr.indexOf(6); // -1</span><br></pre></td></tr></tbody></table></figure><p>indexOf方法还可以接受第二个参数，表示搜索位置的开始。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,1].indexOf(1, 2); // 5</span><br></pre></td></tr></tbody></table></figure><p>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [2, 5, 9, 2];</span><br><span class="line">arr.lastIndexOf(2); //3</span><br></pre></td></tr></tbody></table></figure><p>**注意!!!**indexOf跟lastIndexOf不能用来搜索NaN位置，即它们无法确定数组成员是否包含NaN。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN); // -1</span><br><span class="line">[NaN].lastIndexOf(NaN); // -1</span><br></pre></td></tr></tbody></table></figure><p>因为在这两个方法内部，使用严格相等运算符(===)进行比较，而NaN是唯一一个不等于自身的值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;梳理Array常用的api&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Array常用api梳理一</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/23/Array%E5%B8%B8%E7%94%A8api%E6%A2%B3%E7%90%86%E4%B8%80/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/23/Array%E5%B8%B8%E7%94%A8api%E6%A2%B3%E7%90%86%E4%B8%80/</id>
    <published>2021-04-23T09:22:30.000Z</published>
    <updated>2021-04-23T09:22:30.468Z</updated>
    
    <content type="html"><![CDATA[<p>梳理Array常用的api</p><span id="more"></span><p>Array是JS的原生对象，同时也是一个构造函数，可以用来生成新数组。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = new array(3);</span><br><span class="line">arr.length; // 3</span><br><span class="line">arr; // [empty x 3]</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，Array构造函数的参数3，表示生成一个三位成员的数组，每个位置都是空值。</p><h2 id="静态方法isArray"><a href="#静态方法isArray" class="headerlink" title="静态方法isArray"></a>静态方法isArray</h2><p>Array.isArray()判断参数是否是一个数组，返回一个boolean值</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">typeof arr; // "object"</span><br><span class="line">Array.isArray(arr); // true</span><br></pre></td></tr></tbody></table></figure><h2 id="valueOf与toString"><a href="#valueOf与toString" class="headerlink" title="valueOf与toString"></a>valueOf与toString</h2><p>数组的valueOf方法返回数组本身，toString方法返回数组的字符串形式</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.valueOf(); // [1,2,3]</span><br><span class="line">arr.toString(); // "1,2,3"</span><br></pre></td></tr></tbody></table></figure><h2 id="pop与push"><a href="#pop与push" class="headerlink" title="pop与push"></a>pop与push</h2><p>pop方法用于删除数组的最后一个元素，并返回该元素。<strong>会改变原数组</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.pop(); // 3</span><br><span class="line">arr; [1,2]</span><br></pre></td></tr></tbody></table></figure><p>对空数组使用pop方法，会返回undefined</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].pop(); // undefined</span><br></pre></td></tr></tbody></table></figure><p>push方法用于在数组末端添加一个或多个元素，并返回添加新元素后的数组长度。<strong>会改变原数组</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">arr.push(1, "a", {}, true);</span><br><span class="line">arr; // [1, "a", {}, true];</span><br></pre></td></tr></tbody></table></figure><h2 id="shift与unshift"><a href="#shift与unshift" class="headerlink" title="shift与unshift"></a>shift与unshift</h2><p>shift方法用于删除数组的第一个元素，并返回被删除元素。<strong>会改变原数组</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.shift(); // 1</span><br><span class="line">arr; // [2,3]</span><br></pre></td></tr></tbody></table></figure><p>unshift方法用于在数组的第一个位置添加一个或多个元素，并返回添加新元素后的数组长度。<strong>会改变原数组</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.unshift(4, "a", true, {}); // 7</span><br><span class="line">arr; // [4,"a",true,{},1,2,3]</span><br></pre></td></tr></tbody></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>join方法以指定参数为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">arr.join("|");</span><br><span class="line">arr; // "1|2|3"</span><br></pre></td></tr></tbody></table></figure><p>如果数组成员是undefined、null或空位，会被转化为空字符串。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[undefined, null].join(" "); // " "</span><br><span class="line">["a",, "b"].join("-"); // "a--b"</span><br></pre></td></tr></tbody></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>concat方法用于合并多个数组。它将新数组的成员添加到原数组的后面。<strong>返回一个新数组，原数组不变</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">["hello"].concat(["world"]); // ["hello", "world"]</span><br><span class="line">[1,2,3].concat(4,5,6); // [1,2,3,4,5,6]</span><br></pre></td></tr></tbody></table></figure><p>除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。<br>如果数组成员中包含对象，concat方法返回当前数组的一个浅拷贝。</p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>reverse方法用于颠倒排列数组元素，返回改变后的数组。<strong>会改变原数组</strong></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.reverse(); // [3,2,1]</span><br><span class="line">arr; [3,2,1]</span><br></pre></td></tr></tbody></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>slice方法用于提取目标数组的某一部分值。<strong>返回新数组，原数组不变</strong></p><h3 id="slice-start-end"><a href="#slice-start-end" class="headerlink" title="[].slice(start, end)"></a>[].slice(start, end)</h3><p>slice第一个参数为起始位置（从0开始），第二个参数为结束位置（该位置元素不包含在内）。如果省略第二个元素，则一直返回到原数组的最后一个成员。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.slice(0); // [1,2,3]</span><br><span class="line">arr.slice(1,2); // [2]</span><br><span class="line">arr.slice(); [1,2,3]</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的拷贝。<br>如果slice方法的参数是负数，则表示倒数计算的位置。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.slice(-2); // [2,3]</span><br></pre></td></tr></tbody></table></figure><p>如果第一个参数大于等于数组长度，或者第二个参数小于等于数组长度，则返回空数组。</p><h3 id="Array-prototype-slice-call"><a href="#Array-prototype-slice-call" class="headerlink" title="Array.prototype.slice.call()"></a>Array.prototype.slice.call()</h3><p>slice方法的一个重要应用，将类数组转化为数组。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;梳理Array常用的api&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-04-21T08:40:03.000Z</published>
    <updated>2021-04-21T08:40:04.190Z</updated>
    
    <content type="html"><![CDATA[<p>深浅拷贝的理解与实现</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>浅拷贝是创建一个新的对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。如果其中一个对象改变了这个地址，就会影响到另一个对象。</li></ul><p>  借用<a href="https://juejin.cn/user/3949101466785709">conardLi</a>大佬的图片加以理解:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/9/1/16ce894a1f1b5c32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象。修改新对象不会影响原对象。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/9/1/16ce893a54f6c13d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在深入了解深拷贝与浅拷贝之前，我们简单回顾下堆栈和JavaScript数据类型</p><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><p>JavaScript数据类型分为两种:</p><ol><li>基本数据类型(number、string、boolean、undefined、null、symbol、bigint)</li></ol><blockquote><p>基本数据类型可以直接访问，它们是按值分配的，存放在栈(stack)内存中的简单数据段，数据大小确定，内存空间大小可分配。<br>基本数据类型的复制，会在栈内存中开辟一个新的空间，单独修改变量不会相互影响。</p></blockquote><ol start="2"><li>引用数据类型(object -&gt; Array、Function、Date、RegExp)</li></ol><blockquote><p>存放在堆(heap)内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。<br>引用类型的复制，也会为新变量自动分配一个栈内存空间，但是保存的只是引用类型的一个指针。<br>当指针地址相同时，访问到的堆内存中的具体对象实际是同一个，当改变一个时，另一个也跟着改变。</p></blockquote><h2 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h2><p>在计算机领域中，堆和栈是两种数据结构。</p><ul><li><p>栈(stack)</p><ol><li>自动分配内存空间，会自动释放</li><li>存放基本数据类型的值、引用类型的地址(即对象的引用)，按值访问、先进后出</li><li>动态分配的空间一般由程序员分配释放；若程序员不释放，则程序结束时由OS回收</li><li>对象复制的时候，<strong>复制的是栈中的地址而不是堆中的对象</strong>，两个地址指向同一个对象</li></ol></li><li><p>堆(heap)</p><ol><li>动态分配内存，大小不定，不会自动释放</li><li>存放引用数据类型的对象值、函数的参数值、局部变量的值等，队列优先、先进先出</li><li>引用数据类型的值是保存在堆内存中的对象，JavaScript不允许直接访问堆内存中的位置</li><li>不能直接操作对象的堆内存空间。操作对象时，实际操作的是对象的引用而不是对象本身</li></ol></li></ul><p>我们以一个简单的赋值例子来看下:</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = a;</span><br><span class="line">a = 2;</span><br><span class="line">console.log(a, b); // 2 1</span><br><span class="line">let c = {name: "Dog Lai"};</span><br><span class="line">d = c;</span><br><span class="line">d.name = "lry";</span><br><span class="line">console.log(c, d); // {name: "lry"} {name: "lry"}</span><br></pre></td></tr></tbody></table></figure><p>根据上面的例子，在变量还未变化时，有如下堆栈图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/font-end/deep-shallow%20copy/stack-heap.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当对一个变量进行赋值时，都会在栈内存中开辟一个新的内存空间。但对于基本数据类型而言，新的内存空间存的是数据本身，不会相互影响；对于引用数据类型而言，内存空间存的是一个地址指针(对象的引用)，指向堆内存中的实际对象数据。<br>由此可见，<strong>深浅拷贝是相对于引用数据类型而言的</strong></p><h2 id="赋值与浅拷贝"><a href="#赋值与浅拷贝" class="headerlink" title="赋值与浅拷贝"></a>赋值与浅拷贝</h2><p>我们看下面一个例子，比较赋值与浅拷贝会对对象带来哪些改变</p><p>对象赋值:</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = {</span><br><span class="line">  name: "lry",</span><br><span class="line">  age: 24,</span><br><span class="line">  hobby: ["music", "game", "basketball"]</span><br><span class="line">};</span><br><span class="line">let obj2 = obj1;</span><br><span class="line">obj2.name = "LRY0504";</span><br><span class="line">obj2.hobby[0] = "book";</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></tbody></table></figure><p>上面例子运行后，结果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/font-end/deep-shallow%20copy/copy.png" alt="赋值操作" title="">                </div>                <div class="image-caption">赋值操作</div>            </figure><p>浅拷贝:</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = {</span><br><span class="line">  name: "lry",</span><br><span class="line">  age: 24,</span><br><span class="line">  hobby: ["music", "game", "basketball"]</span><br><span class="line">};</span><br><span class="line">let obj2 = shallowClone(obj1);</span><br><span class="line">obj2.name = "LRY0504";</span><br><span class="line">obj2.hobby[0] = "book";</span><br><span class="line">function shallowClone(obj) {</span><br><span class="line">  let res = {};</span><br><span class="line">  for(const key in obj) {</span><br><span class="line">    if(obj.hasOwnProperty(key)) {</span><br><span class="line">      res[key] = obj[key];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  return res;</span><br><span class="line">}</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></tbody></table></figure><p>上面函数shallowClone是一个简单的浅拷贝实现方式，运行结果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/font-end/deep-shallow%20copy/shallow_copy1.png" alt="浅拷贝" title="">                </div>                <div class="image-caption">浅拷贝</div>            </figure><p>对比上面两个例子可以看出:</p><ul><li>所谓“赋值”，其实是<strong>该对象在栈中的地址，而非堆中的数据</strong>。即两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实改变的都是存储空间的内容，另一个对象也会跟着改变。</li><li>浅拷贝会创建一个新对象，这个对象有着原始对象的一份精确拷贝。如果数据属性是基本数据类型，拷贝的是基本类型的值；如果是引用数据类型，拷贝的就是内存地址。如果一个对象改变了这个地址，就会影响到另一个对象。</li></ul><h2 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h2><h3 id="Object-assign与展开运算符…"><a href="#Object-assign与展开运算符…" class="headerlink" title="Object.assign与展开运算符…"></a>Object.assign与展开运算符…</h3><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = {</span><br><span class="line">  name: "lry",</span><br><span class="line">  age: 24,</span><br><span class="line">  hobby: ["music", "basketball", "game"],</span><br><span class="line">  data: {</span><br><span class="line">    name: "试题信息",</span><br><span class="line">    quesList: [1, 2, [3, 4]]</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">let obj2 = Object.assign({}, obj1);</span><br><span class="line">obj2.name="LRY0504";</span><br><span class="line">obj2.hobby[0] = "book";</span><br><span class="line">obj2.data.name = "试题列表";</span><br><span class="line">obj2.data.quesList[0] = 5;</span><br><span class="line">obj2.data.quesList[2][0] = 6;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></tbody></table></figure><p>运行上面代码，结果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/font-end/deep-shallow%20copy/shallow_copy2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从结果中可以看出：使用Object.assign()拷贝过的对象，第一层数据并没有随着obj2的改变而改变，第二层及更深层级的数据随着obj2的改变而改变。<br>由此可以得出以下结论:<br><strong>Object.assign()第一层是深拷贝，第二层及更深层是浅拷贝</strong><br>展开运算符… 与Object.assign()功能一致，不再具体说明</p><h3 id="concat与slice"><a href="#concat与slice" class="headerlink" title="concat与slice"></a>concat与slice</h3><p>concat与slice都是相对Array层面的浅拷贝</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = [{</span><br><span class="line">  name: "lry",</span><br><span class="line">  age: 24,</span><br><span class="line">  hobby: ["music", "basketball", "game"],</span><br><span class="line">  data: {</span><br><span class="line">    name: "试题信息",</span><br><span class="line">    quesList: [1, 2, [3, 4]]</span><br><span class="line">  }</span><br><span class="line">}];</span><br><span class="line">let obj2 = obj1.concat();</span><br><span class="line">// 或者 let obj2 = obj1.slice();</span><br><span class="line">obj2[0].name="LRY0504";</span><br><span class="line">obj2[0].hobby[0] = "book";</span><br><span class="line">obj2[0].data.name = "试题列表";</span><br><span class="line">obj2[0].data.quesList[0] = 5;</span><br><span class="line">obj2[0].data.quesList[2][0] = 6;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></tbody></table></figure><p>运行上面代码，结果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/font-end/deep-shallow%20copy/shallow_copy3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h2><h3 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h3><p>一说到深拷贝，第一个想到的估计就是这个方法了。这种方法虽然可以实现数组或对象的深拷贝，但<strong>不能处理函数和正则</strong>。</p><blockquote><p>RegExp -&gt;-&gt;- JSON.parse(JSON.stringify()) -&gt;-&gt;- &gt;&gt;&gt; {}<br>Function -&gt;-&gt;- JSON.parse(JSON.stringify()) -&gt;-&gt;- &gt;&gt;&gt; null</p></blockquote><h3 id="迭代递归法"><a href="#迭代递归法" class="headerlink" title="迭代递归法"></a>迭代递归法</h3><blockquote><p>实现原理:<br>遍历对象或数组，直到里面都是基本数据类型，然后再去复制，就是深度拷贝</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function isObject(o) {</span><br><span class="line">  return (typeof o === "object" || typeof o === "function")</span><br><span class="line">  &amp;&amp; o !== null;</span><br><span class="line">}</span><br><span class="line">function deepClone(obj) {</span><br><span class="line">  if(!isObject(obj)) {</span><br><span class="line">    return obj;</span><br><span class="line">  }</span><br><span class="line">  let cloneObj = Array.isArray(obj) ? [] : {};</span><br><span class="line">  for(let key in obj) {</span><br><span class="line">    cloneObj[key] = isObject(obj[key]) ?</span><br><span class="line">    deepClone(obj[key]) : obj[key];</span><br><span class="line">  }</span><br><span class="line">  return cloneObj;</span><br><span class="line">}</span><br><span class="line">let obj1 = {</span><br><span class="line">  name: "lry",</span><br><span class="line">  age: 24,</span><br><span class="line">  hobby: ["music", "basketball", "game"],</span><br><span class="line">  data: {</span><br><span class="line">    name: "试题信息",</span><br><span class="line">    quesList: [1, 2, [3, 4]]</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line">let obj2 = deepClone(obj1);</span><br><span class="line">obj2.name = "LRY0504";</span><br><span class="line">obj2.hobby[0] = "book";</span><br><span class="line">obj2.data.name = "试题列表";</span><br><span class="line">obj2.data.quesList[0] = 5;</span><br><span class="line">obj2.data.quesList[2][0] = 6;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></tbody></table></figure><p>运行上面代码，结果如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Lry0504/image_resources/master/blog/font-end/deep-shallow%20copy/deep_copy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="关于深拷贝的思考"><a href="#关于深拷贝的思考" class="headerlink" title="关于深拷贝的思考"></a>关于深拷贝的思考</h2><p>上面的迭代递归法基本满足深拷贝的应用场景，但无法支持Date、RegExp、symbol、function数据类型</p><h3 id="支持Date数据"><a href="#支持Date数据" class="headerlink" title="支持Date数据"></a>支持Date数据</h3><p>在判断是否是对象后面，加入下面代码:</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (obj instanceof Date) return new Date(obj);</span><br></pre></td></tr></tbody></table></figure><h3 id="支持正则RegExp"><a href="#支持正则RegExp" class="headerlink" title="支持正则RegExp"></a>支持正则RegExp</h3><p>同样在判断Date后面加上以下代码:</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (obj instanceof RegExp) return new RegExp(obj);</span><br></pre></td></tr></tbody></table></figure><h3 id="支持symbol"><a href="#支持symbol" class="headerlink" title="支持symbol"></a>支持symbol</h3><p>在正则RegExp判断后面加上以下代码:</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(obj instanceof Symbol) {</span><br><span class="line">  return Object(Symbol.prototype.ValueOf.call(obj));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="关于function函数"><a href="#关于function函数" class="headerlink" title="关于function函数"></a>关于function函数</h3><p>实际上，深拷贝函数是没有实际的应用场景的，但貌似面试的时候面试官比较热衷于问这个问题…(暂时不考虑函数的拷贝用法)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;深浅拷贝的理解与实现&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/19/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/19/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-04-19T07:20:36.000Z</published>
    <updated>2021-04-19T07:20:37.186Z</updated>
    
    <content type="html"><![CDATA[<p>防抖与节流理解及手写实现</p><span id="more"></span><p>在前端开发中，我们会遇到一些频繁的事件触发（滚动条滑动、鼠标事件、搜索框搜索…），如果不加以限制的话，可能会造成浏览器卡顿。为了解决这个问题，出现了两种解决方案：</p><ul><li>debounce 防抖</li><li>throttle 节流</li></ul><h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>触发事件n秒后才执行，如果在n秒内重新触发，则重新计时</strong>(<em>ps</em>: 有点任性…)。</p><h3 id="初版防抖函数"><a href="#初版防抖函数" class="headerlink" title="初版防抖函数"></a>初版防抖函数</h3><blockquote><p>实现思路：通过定时器控制fn是否实现<br>1、每次触发防抖函数时，先清除上一次的定时器，再开启本次触发定时器<br>2、绑定this指向：使用防抖函数后，fn中的this会指向window，要让this指向fn上下文，则需要绑定this指向 -&gt; fn.apply(context)<br>3、绑定event事件：事件处理函数中会提供事件对象event，但是在debounce函数中打印会是undefined，所以需要对event对象特殊处理 -&gt; fn.apply(context, args)</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, wait) {</span><br><span class="line">  var timeout;</span><br><span class="line">  return function() {</span><br><span class="line">    var context = this;</span><br><span class="line">    var args = arguments;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(function() {</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    }, wait);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="防抖函数立即执行"><a href="#防抖函数立即执行" class="headerlink" title="防抖函数立即执行"></a>防抖函数立即执行</h3><p>在初版防抖函数的基础上，考虑个新需求：我不希望要等到事件停止触发n秒后才执行，我希望它能够立即执行，然后停止触发n秒后才重新触发执行。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) {</span><br><span class="line">  var timeout,result;</span><br><span class="line">  return function() {</span><br><span class="line">    var context = this;</span><br><span class="line">    var args = arguments;</span><br><span class="line">    if(timeout) clearTimeout(timeout);</span><br><span class="line">    if(immediate) {</span><br><span class="line">      //如果已经执行过，不再执行</span><br><span class="line">      var callNow = !timeout;</span><br><span class="line">      //定时器结束并设置为null，则可以再次点击执行了</span><br><span class="line">      timeout = setTimeout(function() {</span><br><span class="line">        timeout = null;</span><br><span class="line">      }, wait);</span><br><span class="line">      if(callNow) result = func.apply(context, args);</span><br><span class="line">    } else {</span><br><span class="line">      timeout = setTimeout(function() {</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      }, wait);</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码值得注意的是：func函数是可能有返回值的，所以debounce函数也需要添加返回结果result。当immediate为false时，因为setTimeout函数的存在，return出来的值一直都是undefined，所以我们只需要在immediate为true的时候才添加返回结果。</p><h3 id="防抖函数使用场景"><a href="#防抖函数使用场景" class="headerlink" title="防抖函数使用场景"></a>防抖函数使用场景</h3><ul><li>避免按钮频繁触发请求</li><li>浏览器窗口resize事件</li><li>文本编辑器实时保存，无任何操作1s后自动保存</li></ul><h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>规定时间内只能触发一次时间；如果规定时间内再触发多次，什么都不做</strong>。</p><h3 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h3><blockquote><p>实现思路:<br>设置时间戳previous开始值为0，当触发事件时，取出当前的时间戳now，减去之前的时间戳previous。<br>如果得到的值大于设置的时间wait，则执行函数func，并更新时间戳previous为当前时间now<br>如果得到的值小于设置时间wait，则什么都不做</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) {</span><br><span class="line">  var previous = 0;</span><br><span class="line">  return function() {</span><br><span class="line">    var now = +new Date();</span><br><span class="line">    var context = this;</span><br><span class="line">    var args = arguments;</span><br><span class="line">    if(now - previous &gt; wait) {</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      previous = now;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>触发事件会立即执行一次，停止触发事件便不再执行</p><h3 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版"></a>定时器版</h3><blockquote><p>实现思路:<br>当触发事件时，设置一个定时器，再次触发该事件的时候<br>如果定时器存在，就不执行func，直到上一轮定时器执行完并且为null，才会执行func，并清除本次定时器</p></blockquote>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) {</span><br><span class="line">  var timeout;</span><br><span class="line">  return function() {</span><br><span class="line">    var context = this;</span><br><span class="line">    var args = arguments;</span><br><span class="line">    if(!timeout) {</span><br><span class="line">      timeout = setTimeout(function() {</span><br><span class="line">        timeout = null;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      }, wait);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>触发事件不会立即执行，n秒后才执行第一次，停止触发事件后还会再执行一次。</p><h3 id="双剑合璧版"><a href="#双剑合璧版" class="headerlink" title="双剑合璧版"></a>双剑合璧版</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) {</span><br><span class="line">  var timeout, context, args;</span><br><span class="line">  var previous = 0;</span><br><span class="line">  var later = function() {</span><br><span class="line">    previous = +new Date();</span><br><span class="line">    timeout = null;</span><br><span class="line">    func.apply(context, args)</span><br><span class="line">  };</span><br><span class="line">  var throttled = function() {</span><br><span class="line">    var now = +new Date();</span><br><span class="line">    //下次触发 func 剩余的时间</span><br><span class="line">    var remaining = wait - (now - previous);</span><br><span class="line">    context = this;</span><br><span class="line">    args = arguments;</span><br><span class="line">    if (remaining &lt;= 0) {</span><br><span class="line">      if (timeout) {</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">      }</span><br><span class="line">      previous = now;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">    } else if (!timeout) {</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line">  return throttled;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="节流函数使用场景"><a href="#节流函数使用场景" class="headerlink" title="节流函数使用场景"></a>节流函数使用场景</h3><ul><li>scroll滚动事件</li><li>浏览器播放</li><li>搜索框实时搜索</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;防抖与节流理解及手写实现&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>水平垂直居中问题</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/15/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/15/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-15T11:28:04.000Z</published>
    <updated>2021-04-15T11:28:04.438Z</updated>
    
    <content type="html"><![CDATA[<p>css中常用的水平垂直居中记录</p><span id="more"></span><p>项目开发中我们经常会遇到盒子的水平垂直居中问题，定宽高的方式有很多，这里不再记录，主要记录下在不定宽高情况下的实现方式。</p><p>下面用到的盒子如下：</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="parent"&gt;</span><br><span class="line">  &lt;div class="son"&gt;测试水平垂直居中&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="flex-margin"><a href="#flex-margin" class="headerlink" title="flex + margin"></a>flex + margin</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: flex;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  margin: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h2><p>常用于图片的居中显示</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h2><p>利用表格布局方式实现</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: table-cell;</span><br><span class="line">  text-align: center;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: grid;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  align-self: center;</span><br><span class="line">  justify-self: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="absolute-四个方向值相等"><a href="#absolute-四个方向值相等" class="headerlink" title="absolute + 四个方向值相等"></a>absolute + 四个方向值相等</h2><p>这种方式需要设置子元素的宽高、并且需要设置”margin: auto”</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  width: xxx;</span><br><span class="line">  height: xxx;</span><br><span class="line">  margin: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="after伪元素"><a href="#after伪元素" class="headerlink" title="after伪元素"></a>after伪元素</h2><p>子元素display需要设置为”inline-block”才生效</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  text-align: center;</span><br><span class="line">}</span><br><span class="line">.parent::after {</span><br><span class="line">  content: '';</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  height: 100%;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="before伪元素"><a href="#before伪元素" class="headerlink" title="before伪元素"></a>before伪元素</h2><p>“font-size: 0” 可以消除标签之间的间隙。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 0;</span><br><span class="line">}</span><br><span class="line">.parent::before {</span><br><span class="line">  content: '';</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  height: 100%;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br><span class="line">.son {</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;css中常用的水平垂直居中记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Css" scheme="https://lry61.cn/Joy-blog/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>BFC记录</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/15/BFC%E8%AE%B0%E5%BD%95/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/15/BFC%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-15T07:35:01.000Z</published>
    <updated>2021-04-15T07:35:01.828Z</updated>
    
    <content type="html"><![CDATA[<p>什么是BFC？原理？使用场景？</p><span id="more"></span><h2 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h2><p>BFC(Block formatting context)直译为“块级格式化上下文”，它是一个独立的渲染区域，规定了内部如何布局，并且与区域外部毫不相关。</p><blockquote><p>通俗一点，创建了BFC的元素就是个独立的盒子，里面子元素的布局不会影响外面元素。</p></blockquote><h2 id="BCF原理"><a href="#BCF原理" class="headerlink" title="BCF原理"></a>BCF原理</h2><ol><li>内部的Box在垂直方向一个接一个的放置。</li><li>Box垂直方向距离由margin决定，属于同一个BFC的两个相邻Box的margin会重叠。</li><li>每个元素的margin box左边，与包含块border box的左边相接触，即使存在浮动也是如此。</li><li>BFC区域不与float box重叠。</li><li>BFC里面的子元素不会影响外面的元素。</li><li>计算BFC高度时，浮动元素也参与计算。</li></ol><h2 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h2><p>满足以下任一条件即可创建BFC:</p><ol><li>根元素</li><li>float属性不是none</li><li>position不为static、relative</li><li>overflow不为visible</li><li>display为inline-block、table-cell、table-caption、flex、line-flex…</li></ol><h2 id="BFC使用场景"><a href="#BFC使用场景" class="headerlink" title="BFC使用场景"></a>BFC使用场景</h2><ol><li>防止margin重叠</li><li>清除内部浮动(解决高度塌陷)</li><li>自适应两栏布局</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是BFC？原理？使用场景？&lt;/p&gt;</summary>
    
    
    
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Css" scheme="https://lry61.cn/Joy-blog/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>call、apply、bind的区别与实现</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/14/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/14/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-14T07:49:27.000Z</published>
    <updated>2021-04-14T07:49:27.700Z</updated>
    
    <content type="html"><![CDATA[<p>了解call、apply、bind异同及实现原理</p><span id="more"></span><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ul><li>call、apply、bind都是函数Function原型链上的方法</li><li>都是用来改变函数执行时内部的this指向</li><li>都可以接收两个或多个参数，第一个为改变后的this指向，后面为可选参数</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>call、apply调用会立即返回结果，bind不会立即调用，而是返回一个新函数</li><li>call的可选参数为参数列表，apply的可选参数为数组或类数组对象</li></ul><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>func.call(thisArg, arg1, arg2, ...)</code></p><ul><li>thisArg: 可选。如果为null或undefined，则指向window</li><li>arg1, arg2,…: 参数列表</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>判断数据类型 <code>Object.prototype.toString.call()</code></p></li><li><p>类数组借用数组方法 <code>Array.prototype.push.call()</code>、<code>[].slice.call(arguments)</code></p></li></ol><h3 id="手写实现call"><a href="#手写实现call" class="headerlink" title="手写实现call"></a>手写实现call</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.iCall = function(context) {</span><br><span class="line">  if(context === null || context === undefined) {</span><br><span class="line">    // 指定null或undefined的this值指向window</span><br><span class="line">    context = window;</span><br><span class="line">  } else {</span><br><span class="line">    // 值为原始值(number、string、boolean)的this会指向该原始值的实例对象</span><br><span class="line">    context = Object(context);</span><br><span class="line">  }</span><br><span class="line">  // 函数的this指向隐式绑定到context上</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 取出执行函数的剩余参数列表</span><br><span class="line">  let args = [...arguments].slice(1);</span><br><span class="line">  let result = context.fn(...args); // 执行函数</span><br><span class="line">  delete context.fn; // 删除上下文属性，避免内存泄漏</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><code>func.apply(thisArg, [arg1, arg2, ...])</code></p><ul><li>thisArg: 可选。如果为null或undefined，则指向window</li><li>arg1, arg2, …: 数组参数列表</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>获取数组最大最小值 <code>Math.max.apply(Math, arr)</code>、<code>Math.min(Math, arr)</code></li></ol><h3 id="手写实现apply"><a href="#手写实现apply" class="headerlink" title="手写实现apply"></a>手写实现apply</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function.prototype.iApply = function(context) {</span><br><span class="line">  if(context === null || context === undefined) {</span><br><span class="line">    context = window;</span><br><span class="line">  } else {</span><br><span class="line">    context = Object(context);</span><br><span class="line">  }</span><br><span class="line">  context.fn = this;</span><br><span class="line">  let result;</span><br><span class="line">  if(arguments[1]) { // 判断是否有剩余参数，如果有则带参执行</span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  } else {</span><br><span class="line">    result = context.fn();</span><br><span class="line">  }</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><code>func.bind(thisArg, arg1, arg2, ...)</code></p><ul><li>thisArg: 传递给目标函数的值。</li><li>arg1, arg2, …: 参数列表。当目标函数被调用后，放在目标函数参数列表中</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>保存函数参数</li></ul><p>  来看一个经典的面试题</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i++) {</span><br><span class="line">  setTimeout(function test() {</span><br><span class="line">    console.log(i); // 依次输出: 6 6 6 6 6</span><br><span class="line">  }, i*1000);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  造成这个现象的原因是在setTimeout异步执行时，i已经变成6了。<br>  如果要让它依次输出1,2,3,4,5，有多种解决办法：</p><ol><li>闭包</li></ol>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i++) {</span><br><span class="line">  (function(i) {</span><br><span class="line">    setTimeout(function() {</span><br><span class="line">      console.log(i); // 依次输出: 1 2 3 4 5</span><br><span class="line">    }, i*1000);</span><br><span class="line">  }(i))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>bind绑定</li></ol>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i &lt;= 5; i++) {</span><br><span class="line">  setTimeout(function(i) {</span><br><span class="line">    console.log(i); // 依次输出: 1 2 3 4 5</span><br><span class="line">  }.bind(null, i), i*1000);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  实际上这里也是返回了一个闭包，它保存了函数的this指向，初始参数，每次i的变化都会被bind的闭包存起来。</p><ul><li>解决回调函数this丢失</li></ul><h3 id="手写实现bind-划重点"><a href="#手写实现bind-划重点" class="headerlink" title="手写实现bind(划重点)"></a>手写实现bind(划重点)</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function.prototype.iBind = function(objThis, ...args) {</span><br><span class="line">  let thisFn = this; //存储源函数及args</span><br><span class="line">  let fToBind = function() {</span><br><span class="line">    // 判断this是否是fToBind实例，即返回的fToBind是否通过new调用</span><br><span class="line">    const isNew = this instanceof fToBind;</span><br><span class="line">    // new调用就绑定到this，否则绑定到传入的objThis上</span><br><span class="line">    const context = isNew ? this : Object(objThis);</span><br><span class="line">    // apply调用源函数绑定this并传参，返回执行结果</span><br><span class="line">    return thisFn.apply(context, args);</span><br><span class="line">  };</span><br><span class="line">  // 复制源函数的prototype给fToBind</span><br><span class="line">  fToBind.prototype = Object.create(thisFn.prototype);</span><br><span class="line">  return fToBind; // 返回拷贝的函数</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解call、apply、bind异同及实现原理&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JS数据类型与类型判断</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</id>
    <published>2021-04-12T12:46:32.000Z</published>
    <updated>2021-04-14T00:54:51.166Z</updated>
    
    <content type="html"><![CDATA[<p>JS数据类型基础知识回顾</p><span id="more"></span><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><p>JavaScript数据类型分为“基本数据类型”和“引用数据类型”。到目前为止，基本数据类型共有7种，引用数据类型1种。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>number</li><li>string</li><li>boolean</li><li>undefined</li><li>null</li><li>symbol(唯一标识符)</li><li>bigint(任意大整数)</li></ul><p>基本数据类型的值是不可变的，前面5种类型日常使用的比较频繁，不再过多记录，这里记录下ES6以后新增的symbol与bigint。</p><h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>symbol是ES6新增的一种基本数据类型，是一种唯一标识符。</p><ol><li><p>定义: <code>let sml = Symbol('symbol')</code></p></li><li><p>特性:</p></li></ol><ul><li><p>唯一性<br>通过symbol声明的两个变量，即使是同一个值也不相等。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let sml2 = Symbol('1');</span><br><span class="line">console.log(sml1 === sml2); // false</span><br></pre></td></tr></tbody></table></figure></li><li><p>可访问性<br>symbol声明的变量，无法通过for…in、object.keys()访问</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let obj = {</span><br><span class="line">  [sml1]: '2'</span><br><span class="line">};</span><br><span class="line">for(let s in obj) {</span><br><span class="line">  console.log(obj[s]); // undefined</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li>常用方法</li></ol><ul><li><p>Object.getOwnPropertySymbols(obj)<br>返回一个数组，成员是当前对象用作属性名的symbol值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol('1');</span><br><span class="line">let obj = {</span><br><span class="line">  [sml1]: '2'</span><br><span class="line">};</span><br><span class="line">let arr = Object.getOwnPropertySymbols(obj);</span><br><span class="line">console.log(arr); // [Symbol(1)]</span><br><span class="line">console.log(obj[arr[0]]); // 2</span><br></pre></td></tr></tbody></table></figure></li><li><p>Symbol.for()<br>使相同参数变量的symbol值相等</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol.for('1');</span><br><span class="line">let sml2 = Symbol.for('1');</span><br><span class="line">console.log(sml1 === sml2); // true</span><br></pre></td></tr></tbody></table></figure></li><li><p>Symbol.keyFor()<br>获取参数值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sml1 = Symbol.for('1');</span><br><span class="line">console.log(Symbol.keyFor(sml1)); // 1</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h4><p>在基本数据类型中，整数通常由number类型表示，但是number类型只能表示某个范围内[-(2^53 - 1) ~ (2^53 - 1)]的整数，超出会失去精度;而bigint则可以表示任意大的整数</p><ol><li>使用方法</li></ol><ul><li><p>末尾加 n</p></li><li><p>构造函数BigInt()</p></li></ul><ol start="2"><li>注意</li></ol><ul><li><p>bigint不能与number一起使用</p></li><li><p>bigint不能与“+”号一起使用</p></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>  引用数据类型object的值是可变的，通常赋值的引用类型，其指向相同的堆内存。<br>  object包括了数值Array、函数Function、特殊的正则RegExp和时间Date</p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof返回一个表示数据类型的字符串</p><ul><li><p>对于基本数据类型<br>返回相应的数据类型，<strong>null除外</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof 1; // number √</span><br><span class="line">typeof '1'; // string √</span><br><span class="line">typeof true; // boolean √</span><br><span class="line">typeof undefined; //undefined √</span><br><span class="line">typeof null; // object ×</span><br><span class="line">typeof NaN; // number √(NaN据说是number类型的...好奇.jpg)</span><br><span class="line">typeof Symbol(); // symbol √</span><br><span class="line">typeof 9007199254740999n; // bigint √</span><br></pre></td></tr></tbody></table></figure></li><li><p>对于引用数据类型<br>返回object，<strong>function除外</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof new Function(); // function √</span><br><span class="line">typeof []; // object ×</span><br><span class="line">typeof new Date(); // object ×</span><br><span class="line">typeof new RegExp(); // object ×</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof用来检测构造函数的prototype属性是否出现在某个实例对象的原型链上，存在返回true，否则返回false。<strong>instanceof是相对引用类型的，基本数据类型不适用</strong></p><pre><code><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array; // true √</span><br><span class="line">new Date() instanceof Date; // true √</span><br><span class="line">'1' instanceof String; // false ×</span><br><span class="line">null instanceof null; // 报错，无法检测</span><br><span class="line">undefined instanceof undefined; //报错，无法检测</span><br></pre></td></tr></tbody></table></figure></code></pre><p>值得注意的是，对象原型链最终都指向了Object，即 <code>Array.prototype._proto_ = Object.prototype</code>。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor与instanceof类似，可能在重写过程中把之前的constructor覆盖掉，导致结果不准确。</p><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p><strong>最常用最全能的方法</strong>。MDN<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">有段描述</a>：</p><blockquote><p>每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型</p></blockquote><pre><code><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call('1'); // [object String]</span><br><span class="line">Object.prototype.toString.call(1); // [object Number]</span><br><span class="line">Object.prototype.toString.call(true); // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(undefined); // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(null); // [object Null]</span><br><span class="line">Object.prototype.toString.call(new Function()); // [object Function]</span><br><span class="line">Object.prototype.toString.call(new Date()); // [object Date]</span><br><span class="line">Object.prototype.toString.call([]); // [object Array]</span><br><span class="line">Object.prototype.toString.call(new RegExp()); // [object RegExp]</span><br></pre></td></tr></tbody></table></figure></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;JS数据类型基础知识回顾&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lry61.cn/Joy-blog/tags/JavaScript/"/>
    
    <category term="基础知识" scheme="https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to Dog Lai&#39;s Blog</title>
    <link href="https://lry61.cn/Joy-blog/2021/04/07/welcome/"/>
    <id>https://lry61.cn/Joy-blog/2021/04/07/welcome/</id>
    <published>2021-04-07T01:13:25.653Z</published>
    <updated>2021-04-09T13:27:00.342Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Dog Lai’s Blog</p><span id="more"></span><p>之前在网上查资料时，经常能看到别人高大上的Blog，脑子里都有个Blog 2.0的想法，刚好这段时间项目期不紧，就想着把之前的Blog升级下，发布一个 Blog 2.0-beat版（花里胡哨的版本）</p><h3 id="Blog-2-0-beat奇思妙想"><a href="#Blog-2-0-beat奇思妙想" class="headerlink" title="Blog 2.0-beat奇思妙想"></a>Blog 2.0-beat奇思妙想</h3><p>对我而言，我希望2.0版本的博客不单单只是一个博客，它更像微信一样，是一个小型社交平台。我不仅可以在这里记录项目中遇到的问题难点，还能够分享生活中的点点滴滴，与别人交流、发朋友圈、上传相册、放置简历…<br>正如我想的那样，2.0-beat coming！</p><h3 id="artitalk-圈子"><a href="#artitalk-圈子" class="headerlink" title="artitalk 圈子"></a>artitalk 圈子</h3><p>对我而言，有时候想在朋友圈发一些自己的想法有诸多不便，我迫切的需要一个平台表达我的某些想法意见；基于此，artitalk 圈子运营而生，它满足我目前的所有幻想，感情树洞、idea…对我意义重大!</p><h3 id="photos-相册"><a href="#photos-相册" class="headerlink" title="photos 相册"></a>photos 相册</h3><p>我希望可以将自己的相册移植到博客中，正好gitHub仓库可以作为图床使用。</p><blockquote><p>我希望后面可以使用时间线来布局我的相册，并且能够配上简短的文字说明<br>这在后面会慢慢考虑功能的实现</p></blockquote><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>如果你喜欢我的博客，请给我个Star吧~</p><blockquote><p>欢迎留言<br>欢迎技术交流<br>欢迎谈论博客优化</p></blockquote><p>感谢你的阅读 Thanks♪(･ω･)ﾉ</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to Dog Lai’s Blog&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>

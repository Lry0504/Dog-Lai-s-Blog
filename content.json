{"meta":{"title":"Dog Lai's Blog","subtitle":"Front-end development engineer","description":"Author:Dog Lai,Category:Personal Blog","author":"Dog Lai","url":"https://lry61.cn/Joy-blog","root":"/Joy-blog/"},"pages":[{"title":"","date":"2021-04-07T02:49:18.000Z","updated":"2021-04-07T08:34:19.124Z","comments":false,"path":"about/index.html","permalink":"https://lry61.cn/Joy-blog/about/index.html","excerpt":"","text":""},{"title":"artitalk","date":"2021-04-08T08:59:11.000Z","updated":"2021-04-08T09:01:01.329Z","comments":false,"path":"artitalk/index.html","permalink":"https://lry61.cn/Joy-blog/artitalk/index.html","excerpt":"","text":""},{"title":"photos","date":"2021-04-09T07:09:41.000Z","updated":"2021-04-09T08:13:24.384Z","comments":false,"path":"photos/index.html","permalink":"https://lry61.cn/Joy-blog/photos/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-07T02:47:50.000Z","updated":"2021-04-07T08:34:15.920Z","comments":false,"path":"tags/index.html","permalink":"https://lry61.cn/Joy-blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS数据类型与类型判断","slug":"JS数据类型与类型判断","date":"2021-04-12T12:46:32.000Z","updated":"2021-04-12T12:48:24.035Z","comments":true,"path":"2021/04/12/JS数据类型与类型判断/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/","excerpt":"JS数据类型基础知识回顾","text":"JS数据类型基础知识回顾 JS数据类型JavaScript数据类型分为“基本数据类型”和“引用数据类型”。到目前为止，基本数据类型共有7种，引用数据类型1种。 基本数据类型 number string boolean undefined null symbol(唯一标识符) bigint(任意大整数) 基本数据类型的值是不可变的，前面5种类型日常使用的比较频繁，不再过多记录，这里记录下ES6以后新增的symbol与bigint。 symbolsymbol是ES6新增的一种基本数据类型，是一种唯一标识符。 定义: let sml = Symbol('symbol') 特性: 唯一性通过symbol声明的两个变量，即使是同一个值也不相等。 123let sml1 = Symbol('1');let sml2 = Symbol('1');console.log(sml1 === sml2); // false 可访问性symbol声明的变量，无法通过for…in、object.keys()访问 1234567let sml1 = Symbol('1');let obj = { [sml1]: '2'};for(let s in obj) { console.log(obj[s]); // undefined} 常用方法 Object.getOwnPropertySymbols(obj)返回一个数组，成员是当前对象用作属性名的symbol值 1234567let sml1 = Symbol('1');let obj = { [sml1]: '2'};let arr = Object.getOwnPropertySymbols(obj);console.log(arr); // [Symbol(1)]console.log(obj[arr[0]]); // 2 Symbol.for()使相同参数变量的symbol值相等 123let sml1 = Symbol.for('1');let sml2 = Symbol.for('1');console.log(sml1 === sml2); // true Symbol.keyFor()获取参数值 12let sml1 = Symbol.for('1');console.log(Symbol.keyFor(sml1)); // 1 bigint在基本数据类型中，整数通常由number类型表示，但是number类型只能表示某个范围内[-(2^53 - 1) ~ (2^53 - 1)]的整数，超出会失去精度;而bigint则可以表示任意大的整数 使用方法 末尾加 n 构造函数BigInt() 注意 symbol不能与number一起使用 symbol不能与“+”号一起使用 引用数据类型 引用数据类型object的值是可变的，通常赋值的引用类型，其指向相同的堆内存。 object包括了数值Array、函数Function、特殊的正则RegExp和时间Date 类型判断typeoftypeof返回一个表示数据类型的字符串 对于基本数据类型返回相应的数据类型，null除外 12345678typeof 1; // number √typeof '1'; // string √typeof true; // boolean √typeof undefined; //undefined √typeof null; // object ×typeof NaN; // number √(NaN据说是number类型的...好奇.jpg)typeof Symbol(); // symbol √typeof 9007199254740999n; // bigint √ 对于引用数据类型返回object，function除外 1234typeof new Function(); // function √typeof []; // object ×typeof new Date(); // object ×typeof new RegExp(); // object × instanceofinstanceof用来检测构造函数的prototype属性是否出现在某个实例对象的原型链上，存在返回true，否则返回false。instanceof是相对引用类型的，基本数据类型不适用 12345[] instanceof Array; // true √new Date() instanceof Date; // true √'1' instanceof String; // false ×null instanceof null; // 报错，无法检测undefined instanceof undefined; //报错，无法检测 值得注意的是，对象原型链最终都指向了Object，即 Array.prototype._proto_ = Object.prototype。 constructorconstructor与instanceof类似，可能在重写过程中把之前的constructor覆盖掉，导致结果不准确。 Object.prototype.toString.call()最常用最全能的方法。MDN有段描述： 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型 123456789Object.prototype.toString.call('1'); // [object String]Object.prototype.toString.call(1); // [object Number]Object.prototype.toString.call(true); // [object Boolean]Object.prototype.toString.call(undefined); // [object Undefined]Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call(new Function()); // [object Function]Object.prototype.toString.call(new Date()); // [object Date]Object.prototype.toString.call([]); // [object Array]Object.prototype.toString.call(new RegExp()); // [object RegExp]","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Welcome to Dog Lai's Blog","slug":"welcome","date":"2021-04-07T01:13:25.653Z","updated":"2021-04-09T13:27:00.342Z","comments":true,"path":"2021/04/07/welcome/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/07/welcome/","excerpt":"Welcome to Dog Lai’s Blog","text":"Welcome to Dog Lai’s Blog 之前在网上查资料时，经常能看到别人高大上的Blog，脑子里都有个Blog 2.0的想法，刚好这段时间项目期不紧，就想着把之前的Blog升级下，发布一个 Blog 2.0-beat版（花里胡哨的版本） Blog 2.0-beat奇思妙想对我而言，我希望2.0版本的博客不单单只是一个博客，它更像微信一样，是一个小型社交平台。我不仅可以在这里记录项目中遇到的问题难点，还能够分享生活中的点点滴滴，与别人交流、发朋友圈、上传相册、放置简历…正如我想的那样，2.0-beat coming！ artitalk 圈子对我而言，有时候想在朋友圈发一些自己的想法有诸多不便，我迫切的需要一个平台表达我的某些想法意见；基于此，artitalk 圈子运营而生，它满足我目前的所有幻想，感情树洞、idea…对我意义重大! photos 相册我希望可以将自己的相册移植到博客中，正好gitHub仓库可以作为图床使用。 我希望后面可以使用时间线来布局我的相册，并且能够配上简短的文字说明这在后面会慢慢考虑功能的实现 写在最后如果你喜欢我的博客，请给我个Star吧~ 欢迎留言欢迎技术交流欢迎谈论博客优化 感谢你的阅读 Thanks♪(･ω･)ﾉ","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}
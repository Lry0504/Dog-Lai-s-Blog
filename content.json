{"meta":{"title":"Dog Lai's Blog","subtitle":"Front-end development engineer","description":"Author:Dog Lai,Category:Personal Blog","author":"Dog Lai","url":"https://lry61.cn/Joy-blog","root":"/Joy-blog/"},"pages":[{"title":"photos","date":"2021-04-09T07:09:41.000Z","updated":"2021-04-09T08:13:24.384Z","comments":false,"path":"photos/index.html","permalink":"https://lry61.cn/Joy-blog/photos/index.html","excerpt":"","text":""},{"title":"artitalk","date":"2021-04-08T08:59:11.000Z","updated":"2021-04-08T09:01:01.329Z","comments":false,"path":"artitalk/index.html","permalink":"https://lry61.cn/Joy-blog/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-07T02:47:50.000Z","updated":"2021-04-07T08:34:15.920Z","comments":false,"path":"tags/index.html","permalink":"https://lry61.cn/Joy-blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-07T02:49:18.000Z","updated":"2021-04-07T08:34:19.124Z","comments":false,"path":"about/index.html","permalink":"https://lry61.cn/Joy-blog/about/index.html","excerpt":"","text":""}],"posts":[{"title":"面试之查缺补漏一","slug":"面试之查缺补漏一","date":"2021-05-17T03:50:40.000Z","updated":"2021-05-17T03:50:40.442Z","comments":true,"path":"2021/05/17/面试之查缺补漏一/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/05/17/%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B8%80/","excerpt":"记录面试中回答的不太好的知识点","text":"记录面试中回答的不太好的知识点 今天体验了一下某公司的面试，感觉还是比较注重基础知识的，但是后面问的自我感觉回答的越来越差，果然面试容易让人自闭。挫败感肯定是有的，但是还是得不断前行啊…话不多说，先记录下面试中遇到的问题，下次不要再不会了！！！┭┮﹏┭┮ transition与animation的区别transition是过渡属性，强调过渡，它的实现需要触发一个事件（鼠标聚焦、点击、hover等）才执行动画，只有开始关键帧和结束关键帧。animation是动画属性，它的实现不需要触发事件，设定好时间后可以自己执行，且可以循环动画。可以设置多个关键帧完成动画。 transition语法 transition-property: 规定应用过渡的CSS属性名称transition-duration: 规定过渡效果花费的时间，默认是0transition-timing-function: 规定过渡效果的时间曲线transition-delay: 规定过渡效果何时开始 简写： transition: property duration timing-function delay transition虽然好用，但是也存在很多的限制： transition需要一个事件来触发，比如hover，所以没法在网页加载时自动发生 transition是一次性的，不能重复发生，除非一再触发 transition只能定义开始状态和结束状态，不能定义中间状态 一条transition规则，只能定义一个属性的变化，不能涉及多个属性 animation @keyframes规则用于创建动画。在@keyframes中规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果。 animation-name: 规定@keyframes动画的名称animation-duration: 规定动画完成一个周期所花费的秒或毫秒animation-timing-function: 规定动画的速度曲线，默认是”ease”animation-delay: 规定动画何时开始，默认是0animation-iteration-count: 规定动画被播放的次数，默认是1animation-direction: 规定动画是否在下一个周期逆向播放，默认是”normal”animation-play-state: 规定动画是否在运行或暂停，默认是”running”animation-fill-mode: 规定对象动画时间之外的状态 简写: animation: name duration timing-function delay iteration-count direction; localhost与127.0.0.1的区别 localhost localhost其实是域名，一般windows系统默认将localhost指向127.0.0.1，但是localhost并不等于127.0.0.1，localhost指向的IP地址是可以配置的。localhost不经过网卡传输，它不受网络防火墙和网卡相关的限制 127.0.0.1 凡是以127开头的IP地址，都是回环地址，其所在的回环接口一般被理解为虚拟网卡，并不是真正的路由接口。 所谓的回环地址，通俗的讲，就是我们在主机上发送给127开头的IP地址的数据包会被发送的主机自己接收，根本传不出去，外部设备也无法通过回环地址访问到本机。 正常的数据包会从IP层进入链路层，然后发送到网络上‘而给回环地址发送数据包，数据包会直接被发送主机的IP层获取，后面就没有链路层什么事了 128.0.0.1经常被默认配置为localhost的IP地址 react-routerV4为什么要用switchSwitch是排他性路由，只有一个路由会被渲染，并且总是渲染第一个匹配到的组件，更好进行路由匹配，避免重复匹配路由","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://lry61.cn/Joy-blog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JS数组扁平化","slug":"JS数组扁平化","date":"2021-05-06T00:56:46.000Z","updated":"2021-05-06T01:07:50.275Z","comments":true,"path":"2021/05/06/JS数组扁平化/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/05/06/JS%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/","excerpt":"JS扁平化的实现","text":"JS扁平化的实现 所谓数组扁平化，就是将一个多层嵌套的数组，通过某种方式，转化为只有一层的数组 全局变量： 1let array = [[1,2,3],4,5,6,[[7]],[]]; 递归 思路：循环遍历数组，判断循环的元素是否仍是数组。如果是，则递归调用 1234567891011function flatten(arr, result = []) { for(let item of arr) { if(Array.isArray(item)) { flatten(item, result); } else { result.push(item); } } return result;}console.log(flatten(array)); // [1,2,3,4,5,6,7] reduce + concat 思路：reduce遍历数组的每一个元素，如果该元素仍是数组，则重新调用该方法，否则concat到数组中 123456function flatten(arr) { return arr.reduce((acc, cur) =&gt; { return acc.concat(Array.isArray(cur) ? flatten(cur) : cur); }, [])}console.log(flatten(array)); // [1,2,3,4,5,6,7] ES6展开运算符… 思路：ES6中的展开运算符用来取出参数对象中的所有可遍历属性，拷贝到当前对象中 1console.log([].concat(...array)); // [1,2,3,4,5,6,[7]] [].concat(...arr)只能拉平一层数组，但我们根据这个可以想到，利用while循环判断数组中某个元素是否仍为数组，如果仍是数组，则继续拉平。 1234567function flatten(arr) { while(arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr); } return arr;}console.log(flatten(array)); // [1,2,3,4,5,6,7] flat 思路：[].flat(index)可以拉平数组，其中index表示拉平多少层数组。如果要拉平无限层数组，则可以使用Infinity参数 1console.log(array.flat(Infinity)); // [1,2,3,4,5,6,7] toString调用 思路：如果数组中的元素都是数字，我们才可以考虑使用toString方法。调用toString方法，返回一个用逗号分隔的扁平字符串。利用split分隔逗号，得到一个string数组，在遍历数组每个元素，转化为number类型 1234function flatten(arr) { return arr.toString().split(\",\").map(item =&gt; +item)}console.log(flatten(array)); // [1,2,3,4,5,6,7,0] 上面方法存在很大的局限性： 如果arr中存在空数组，则会被转化成空字符串，转成number时变为0 如果数组中存在非数字，则会产生错误结果","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"手写Promise.all","slug":"手写Promise-all","date":"2021-04-27T08:35:49.000Z","updated":"2021-04-27T09:11:02.226Z","comments":true,"path":"2021/04/27/手写Promise-all/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/27/%E6%89%8B%E5%86%99Promise-all/","excerpt":"手写一个简单的promise.all","text":"手写一个简单的promise.all 实现思路：Promise.all需要等到所有的promise的状态都变成fulfilled之后才resolve，但只要有一个promise失败就返回失败的结果 实现代码： 1234567891011121314151617181920Promise.all = function(arr) { return new Promise(function(resolve, reject) { if(!Array.isArray(arr)) { throw new Error(\"this is not array\"); } let dataArr = []; let num = 0; for(let i = 0; i &lt; arr.length; i++) { arr[i].then(function(data) { dataArr.push(data); num++; if(num === arr.length) { return resolve(data); } }).catch(function(error) { return reject(error); }) } })}","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"JS数组去重","slug":"JS数组去重","date":"2021-04-26T02:27:44.000Z","updated":"2021-04-26T02:27:44.984Z","comments":true,"path":"2021/04/26/JS数组去重/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/26/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"JS数组去重的几种实现方式","text":"JS数组去重的几种实现方式 JS数组去重问题也是近几年来面试手写的高频问题，这里简单记录下不同的实现方式及无法去重的情况。下面数组应用于每个实现方式中 1234567let arr = [ 1, 1, true, \"true\", \"false\", false, NaN, \"NaN\", null, undefined, 15, undefined, 15, {}, 0, \"a\", {}, 0, \"a\", NaN, null, undefined] 双层循环 实现思路:利用双层for循环嵌套，然后用splice去重当循环数组第一层的值与第二层的值相同的时候，删除第二层相对应的值。 123456789101112function unique(arr) { for(let i = 0; i &lt; arr.length; i++) { for(let j = i + 1; j &lt; arr.length; j++) { if(arr[i] === arr[j]) { arr.splice(j, 1); j--; } } } return arr;}console.log(unique(arr)); 上面结果中可以看出：双层循环的方法无法去重NaN和{} indexOf循环 实现思路:利用indexOf循环数组，判断结果数组res中是否存在当前元素。如果存在，则跳过；否则把当前元素添加到结果数组res中。 12345678910function unique(arr) { let res = []; for(let i = 0; i &lt; arr.length; i++) { if(res.indexOf(arr[i]) === -1) { res.push(arr[i]); } } return res;}console.log(unique(arr)); 上面结果可以看出：indexOf循环的方法无法去重NaN和{} 排序后去重 实现思路:将数组用sort排序后，相同的值便会在相邻位置。结果数组先存入数组第一个值，然后从第二个值开始，判断与前一个值是否相同。如果相同，则说明重复；否则放进结果数组res中。 1234567891011function unique(arr) { arr = arr.sort(); let res = [arr[0]]; for(let i = 1; i &lt; arr.length; i++) { if(arr[i] !== arr[i - 1]) { res.push(arr[i]); } } return res;}console.log(unique(arr)); 上面结果可以看出：排序后去重的方法无法去重NaN和{} 利用includes 实现思路:判断结果数组中是否包含某个值；如果包含，则跳过；否则放进结果数组res中 12345678910function unique(arr) { let res = []; for(let i = 0; i &lt; arr.length; i++) { if(!res.includes(arr[i])) { res.push(arr[i]); } } return res;}console.log(unique(arr)); 上面结果可以看出：includes的方法无法去重{} 利用filter 实现思路:判断数组中当前元素的第一个索引是否是filter中当前的索引值 123456function unique(arr) { return arr.filter((item, index, arr) =&gt; { return arr.indexOf(item) === index; })}console.log(unique(arr)); 上面结果可以看出：filter的方法无法去重{}，并且把NaN删掉了 reduce + includes 123456function unique(arr) { return arr.reduce((acc, cur) =&gt; acc.includes(cur) ? acc : [...acc, cur], [] )}console.log(unique(arr)); 上面结果可以看出：reduce+includes的方法无法去重{} 利用Set 实现思路:Set对象是值的集合，你可以按照插入的顺序迭代元素。Set对象中的元素只会出现一次，即Set中的元素是唯一的 1234function unique(arr) { return [...new Set(arr)];}console.log(unique(arr)); 上面结果可以看出：Set的方法无法去重{} 利用hasOwnPropertyhasOwnProperty方法会返回一个布尔值，指示对象本身属性中是否具有指定的属性（是否有指定的值）。此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。 实现思路:利用一个空对象obj，把数组的值存成obj对象的key值，如obj[arr[item1]] = true，判断另一个值obj[arr[item2]]是否存在，如果存在，则是相同的值 1234567function unique(arr) { let obj = {}; return arr.filter((item, index, arr) =&gt; { return obj.hasOwnProperty(item) ? false : (obj[item] = true) })}console.log(unique(arr)); 从结果中可以看到，这个方法存在一些问题：true与”true”是不同的，但是Object[true]和Object[“true”]却是同一个引用(对象key值只能是字符串)解决办法：使用typeof item + item拼接成字符串作为key值 12345678function unique(arr) { let obj = {}; return arr.filter((item, index, arr) =&gt; { return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) })}console.log(unique(arr)); 我们知道，如果你数组中存在对象时，如{value: 1}，typeof item + item的结果都是object[object Object]解决办法：使用JSON.stringify()将对象序列化来避免相同的键值 12345678function unique(arr) { let obj = {}; return arr.filter((item, index, arr) =&gt; { return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) })}console.log(unique(arr)); 这种方式可以满足所有的条件去重。 利用Map 实现思路:创建一个空的Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果 1234567891011121314function unique(arr) { let map = new Map(); let array = []; for(let i = 0; i &lt; arr.length; i++) { if(map.has(arr[i])) { // 如果存在该key值 map.set(arr[i], true); } else { map.set(arr[i], false); array.push(arr[i]); } } return array;}console.log(unique(arr)); 上面结果可以看出：Map的方法无法去重{} 递归 12345678910111213141516function unique(arr) { arr.sort(function(a, b) { return a - b; }); function loop(index) { if(index &gt;= 1) { if(arr[index] === arr[index - 1]) { arr.splice(index, 1); } loop(index - 1); } } loop(arr.length - 1); return arr;}console.log(unique(arr)); 上面结果可以看出：递归循环的方法无法去重NaN、null、0、”a”和{}","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Array常用api梳理二","slug":"Array常用api梳理二","date":"2021-04-23T11:50:46.000Z","updated":"2021-04-23T11:50:47.295Z","comments":true,"path":"2021/04/23/Array常用api梳理二/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/23/Array%E5%B8%B8%E7%94%A8api%E6%A2%B3%E7%90%86%E4%BA%8C/","excerpt":"梳理Array常用的api","text":"梳理Array常用的api splicesplice方法用于删除原数组的部分成员，并可以在删除的位置插入新的数组成员，返回值是被删除的元素。会改变原数组[].splice(start, count, addItem1, addItem2, ...)splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有参数，则表示要插入数组的新元素。 12345let arr = [1,2,3,4,5];arr.splice(3,2); // [4,5]arr; // [1,2,3]arr.splice(0,1,4,5);arr; // [4,5,2,3] 如果只提供第一个参数，等同于将原数组在指定位置拆分为两个数组。 sortsort方法用于对数组进行排序，默认按照字典顺序(值会先被转成字符串，再按照字典顺序排列)排序。会改变原数组 123[\"d\",\"b\",\"c\",\"a\"].sort(); // [\"a\",\"b\",\"c\",\"d\"][2,3,4,1].sort(); // [1,2,3,4][11,101].sort(); // [101,11] 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 123[10111, 1101, 111].sort(function(a, b) { return a - b;}); // [111, 1101, 10111] 上面代码中，sort的参数函数接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，则表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个前面。 mapmap方法将所有的数组成员依次传入参数函数，然后把每一次的执行结果组成一个新的数组返回。原数组不变 123let arr = [1,2,3];arr.map(n =&gt; n+1); // [2,3,4]arr; // [1,2,3] map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置、数组本身。 1[1,2,3].map((item, index, arr) =&gt; item * index); // [0, 2, 6] map方法还可以接受第二个参数，用来绑定回调函数内部的this指向。 1234let arr = [1,2,3];[1,2].map(function(e) { return this[e];}, arr); // [2,3] 如果数组中有空位，map方法的回调函数在这个位置不会执行，会跳过数组空位。 1234var f = function(n) { return \"a\"; };[1, undefined, 2].map(f); // [\"a\", \"a\", \"a\"][1, null, 2].map(f); // [\"a\", \"a\", \"a\"][1, , 2].map(f); // [\"a\", , \"a\"] 上面代码中，map方法不会跳过undefined和null，但是会跳过空位。 forEachforEach方法与map方法类似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只是用来操作数据。其他使用方式与map基本一样，不再重复。 filterfilter方法用于过滤数组成员，满足条件的成员组成一个新的数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新的数组返回。原数组不变 123[1,2,3,4,5].filter(function(item) { return item &gt; 3;}); // [4,5] filter方法的参数函数同样可以接受三个参数：当前成员、当前位置、原数组。 123[1,2,3,4,5].filter(function(item, index, arr) { return item % 2 === 0;}); // [2,4] filter方法也可以接受第二个参数，用来绑定参数函数内部的this指向。 some与every这两个方法类似断言，返回一个boolean值，表示判断数组成员是否符合某种条件。他们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置、原数组，返回一个boolean值。some方法是只要一个成员返回true，则整个some方法的返回值都是true。 1234let arr = [1,2,3,4,5];arr.some(function(item, index, arr) { return item &gt;= 3;}); // true every方法是所有成员的返回值都是true，结果才是true 1234let arr = [1,2,3,4,5];arr.every(function(item, index, arr) { return item &gt;= 3;}); // false **注意!!!**对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。 123function isEven(x) { return x % 2 === 0 };[].some(isEven); // false[].every(isEven); // true some与every也可以接受第二个参数用来绑定参数函数内部的this指向。 reducereduce方法依次处理数组中的每一个成员，最终累计为一个值。reduce方法第一个参数是一个函数，该函数接受四个参数： 累积变量：默认为数组第一个成员； 当前变量：默认为数组第二个成员； 当前位置：从0开始； 原数组 这四个参数中，只有前两个是必须的，后两个可选。如果要对累积变量指定初值，可以把它放在reduce方法的第二个参数上。 123[1,2,3,4,5].reduce(function(a, b) { return a + b;}, 10); // 25 上面代码指定参数a的初值为10，所有数组从10开始累加，最终结果为25。此时，b是从数组的第一个成员开始遍历。 indexOf与lastIndexOfindexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 123let arr = [1,2,3,4,5];arr.indexOf(2); // 1arr.indexOf(6); // -1 indexOf方法还可以接受第二个参数，表示搜索位置的开始。 1[1,2,3,4,5,1].indexOf(1, 2); // 5 lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 12let arr = [2, 5, 9, 2];arr.lastIndexOf(2); //3 **注意!!!**indexOf跟lastIndexOf不能用来搜索NaN位置，即它们无法确定数组成员是否包含NaN。 12[NaN].indexOf(NaN); // -1[NaN].lastIndexOf(NaN); // -1 因为在这两个方法内部，使用严格相等运算符(===)进行比较，而NaN是唯一一个不等于自身的值。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Array常用api梳理一","slug":"Array常用api梳理一","date":"2021-04-23T09:22:30.000Z","updated":"2021-04-23T09:22:30.468Z","comments":true,"path":"2021/04/23/Array常用api梳理一/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/23/Array%E5%B8%B8%E7%94%A8api%E6%A2%B3%E7%90%86%E4%B8%80/","excerpt":"梳理Array常用的api","text":"梳理Array常用的api Array是JS的原生对象，同时也是一个构造函数，可以用来生成新数组。 123let arr = new array(3);arr.length; // 3arr; // [empty x 3] 上面代码中，Array构造函数的参数3，表示生成一个三位成员的数组，每个位置都是空值。 静态方法isArrayArray.isArray()判断参数是否是一个数组，返回一个boolean值 123let arr = [1,2,3];typeof arr; // \"object\"Array.isArray(arr); // true valueOf与toString数组的valueOf方法返回数组本身，toString方法返回数组的字符串形式 123let arr = [1,2,3];arr.valueOf(); // [1,2,3]arr.toString(); // \"1,2,3\" pop与pushpop方法用于删除数组的最后一个元素，并返回该元素。会改变原数组 123let arr = [1,2,3];arr.pop(); // 3arr; [1,2] 对空数组使用pop方法，会返回undefined 1[].pop(); // undefined push方法用于在数组末端添加一个或多个元素，并返回添加新元素后的数组长度。会改变原数组 123let arr = [];arr.push(1, \"a\", {}, true);arr; // [1, \"a\", {}, true]; shift与unshiftshift方法用于删除数组的第一个元素，并返回被删除元素。会改变原数组 123let arr = [1,2,3];arr.shift(); // 1arr; // [2,3] unshift方法用于在数组的第一个位置添加一个或多个元素，并返回添加新元素后的数组长度。会改变原数组 123let arr = [1,2,3];arr.unshift(4, \"a\", true, {}); // 7arr; // [4,\"a\",true,{},1,2,3] joinjoin方法以指定参数为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 123let arr = [1,2,3]arr.join(\"|\");arr; // \"1|2|3\" 如果数组成员是undefined、null或空位，会被转化为空字符串。 12[undefined, null].join(\" \"); // \" \"[\"a\",, \"b\"].join(\"-\"); // \"a--b\" concatconcat方法用于合并多个数组。它将新数组的成员添加到原数组的后面。返回一个新数组，原数组不变 12[\"hello\"].concat([\"world\"]); // [\"hello\", \"world\"][1,2,3].concat(4,5,6); // [1,2,3,4,5,6] 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。如果数组成员中包含对象，concat方法返回当前数组的一个浅拷贝。 reversereverse方法用于颠倒排列数组元素，返回改变后的数组。会改变原数组 123let arr = [1,2,3];arr.reverse(); // [3,2,1]arr; [3,2,1] sliceslice方法用于提取目标数组的某一部分值。返回新数组，原数组不变 [].slice(start, end)slice第一个参数为起始位置（从0开始），第二个参数为结束位置（该位置元素不包含在内）。如果省略第二个元素，则一直返回到原数组的最后一个成员。 1234let arr = [1,2,3];arr.slice(0); // [1,2,3]arr.slice(1,2); // [2]arr.slice(); [1,2,3] 上面代码中，最后一个例子slice没有参数，实际上等于返回一个原数组的拷贝。如果slice方法的参数是负数，则表示倒数计算的位置。 12let arr = [1,2,3];arr.slice(-2); // [2,3] 如果第一个参数大于等于数组长度，或者第二个参数小于等于数组长度，则返回空数组。 Array.prototype.slice.call()slice方法的一个重要应用，将类数组转化为数组。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2021-04-21T08:40:03.000Z","updated":"2021-04-21T08:40:04.190Z","comments":true,"path":"2021/04/21/深拷贝与浅拷贝/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"深浅拷贝的理解与实现","text":"深浅拷贝的理解与实现 概念 浅拷贝是创建一个新的对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。如果其中一个对象改变了这个地址，就会影响到另一个对象。 借用conardLi大佬的图片加以理解: 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象。修改新对象不会影响原对象。 在深入了解深拷贝与浅拷贝之前，我们简单回顾下堆栈和JavaScript数据类型 JavaScript数据类型JavaScript数据类型分为两种: 基本数据类型(number、string、boolean、undefined、null、symbol、bigint) 基本数据类型可以直接访问，它们是按值分配的，存放在栈(stack)内存中的简单数据段，数据大小确定，内存空间大小可分配。基本数据类型的复制，会在栈内存中开辟一个新的空间，单独修改变量不会相互影响。 引用数据类型(object -&gt; Array、Function、Date、RegExp) 存放在堆(heap)内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。引用类型的复制，也会为新变量自动分配一个栈内存空间，但是保存的只是引用类型的一个指针。当指针地址相同时，访问到的堆内存中的具体对象实际是同一个，当改变一个时，另一个也跟着改变。 堆与栈在计算机领域中，堆和栈是两种数据结构。 栈(stack) 自动分配内存空间，会自动释放 存放基本数据类型的值、引用类型的地址(即对象的引用)，按值访问、先进后出 动态分配的空间一般由程序员分配释放；若程序员不释放，则程序结束时由OS回收 对象复制的时候，复制的是栈中的地址而不是堆中的对象，两个地址指向同一个对象 堆(heap) 动态分配内存，大小不定，不会自动释放 存放引用数据类型的对象值、函数的参数值、局部变量的值等，队列优先、先进先出 引用数据类型的值是保存在堆内存中的对象，JavaScript不允许直接访问堆内存中的位置 不能直接操作对象的堆内存空间。操作对象时，实际操作的是对象的引用而不是对象本身 我们以一个简单的赋值例子来看下: 12345678let a = 1;let b = a;a = 2;console.log(a, b); // 2 1let c = {name: \"Dog Lai\"};d = c;d.name = \"lry\";console.log(c, d); // {name: \"lry\"} {name: \"lry\"} 根据上面的例子，在变量还未变化时，有如下堆栈图: 当对一个变量进行赋值时，都会在栈内存中开辟一个新的内存空间。但对于基本数据类型而言，新的内存空间存的是数据本身，不会相互影响；对于引用数据类型而言，内存空间存的是一个地址指针(对象的引用)，指向堆内存中的实际对象数据。由此可见，深浅拷贝是相对于引用数据类型而言的 赋值与浅拷贝我们看下面一个例子，比较赋值与浅拷贝会对对象带来哪些改变 对象赋值: 12345678910let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"game\", \"basketball\"]};let obj2 = obj1;obj2.name = \"LRY0504\";obj2.hobby[0] = \"book\";console.log(obj1);console.log(obj2); 上面例子运行后，结果如下: 赋值操作 浅拷贝: 12345678910111213141516171819let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"game\", \"basketball\"]};let obj2 = shallowClone(obj1);obj2.name = \"LRY0504\";obj2.hobby[0] = \"book\";function shallowClone(obj) { let res = {}; for(const key in obj) { if(obj.hasOwnProperty(key)) { res[key] = obj[key]; } } return res;}console.log(obj1);console.log(obj2); 上面函数shallowClone是一个简单的浅拷贝实现方式，运行结果如下: 浅拷贝 对比上面两个例子可以看出: 所谓“赋值”，其实是该对象在栈中的地址，而非堆中的数据。即两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实改变的都是存储空间的内容，另一个对象也会跟着改变。 浅拷贝会创建一个新对象，这个对象有着原始对象的一份精确拷贝。如果数据属性是基本数据类型，拷贝的是基本类型的值；如果是引用数据类型，拷贝的就是内存地址。如果一个对象改变了这个地址，就会影响到另一个对象。 浅拷贝的实现Object.assign与展开运算符…Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 1234567891011121314151617let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"basketball\", \"game\"], data: { name: \"试题信息\", quesList: [1, 2, [3, 4]] }};let obj2 = Object.assign({}, obj1);obj2.name=\"LRY0504\";obj2.hobby[0] = \"book\";obj2.data.name = \"试题列表\";obj2.data.quesList[0] = 5;obj2.data.quesList[2][0] = 6;console.log(obj1);console.log(obj2); 运行上面代码，结果如下: 从结果中可以看出：使用Object.assign()拷贝过的对象，第一层数据并没有随着obj2的改变而改变，第二层及更深层级的数据随着obj2的改变而改变。由此可以得出以下结论:Object.assign()第一层是深拷贝，第二层及更深层是浅拷贝展开运算符… 与Object.assign()功能一致，不再具体说明 concat与sliceconcat与slice都是相对Array层面的浅拷贝 123456789101112131415161718let obj1 = [{ name: \"lry\", age: 24, hobby: [\"music\", \"basketball\", \"game\"], data: { name: \"试题信息\", quesList: [1, 2, [3, 4]] }}];let obj2 = obj1.concat();// 或者 let obj2 = obj1.slice();obj2[0].name=\"LRY0504\";obj2[0].hobby[0] = \"book\";obj2[0].data.name = \"试题列表\";obj2[0].data.quesList[0] = 5;obj2[0].data.quesList[2][0] = 6;console.log(obj1);console.log(obj2); 运行上面代码，结果如下: 深拷贝的实现JSON.parse(JSON.stringify())一说到深拷贝，第一个想到的估计就是这个方法了。这种方法虽然可以实现数组或对象的深拷贝，但不能处理函数和正则。 RegExp -&gt;-&gt;- JSON.parse(JSON.stringify()) -&gt;-&gt;- &gt;&gt;&gt; {}Function -&gt;-&gt;- JSON.parse(JSON.stringify()) -&gt;-&gt;- &gt;&gt;&gt; null 迭代递归法 实现原理:遍历对象或数组，直到里面都是基本数据类型，然后再去复制，就是深度拷贝 1234567891011121314151617181920212223242526272829303132function isObject(o) { return (typeof o === \"object\" || typeof o === \"function\") &amp;&amp; o !== null;}function deepClone(obj) { if(!isObject(obj)) { return obj; } let cloneObj = Array.isArray(obj) ? [] : {}; for(let key in obj) { cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]; } return cloneObj;}let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"basketball\", \"game\"], data: { name: \"试题信息\", quesList: [1, 2, [3, 4]] }};let obj2 = deepClone(obj1);obj2.name = \"LRY0504\";obj2.hobby[0] = \"book\";obj2.data.name = \"试题列表\";obj2.data.quesList[0] = 5;obj2.data.quesList[2][0] = 6;console.log(obj1);console.log(obj2); 运行上面代码，结果如下: 关于深拷贝的思考上面的迭代递归法基本满足深拷贝的应用场景，但无法支持Date、RegExp、symbol、function数据类型 支持Date数据在判断是否是对象后面，加入下面代码: 1if (obj instanceof Date) return new Date(obj); 支持正则RegExp同样在判断Date后面加上以下代码: 1if (obj instanceof RegExp) return new RegExp(obj); 支持symbol在正则RegExp判断后面加上以下代码: 123if(obj instanceof Symbol) { return Object(Symbol.prototype.ValueOf.call(obj));} 关于function函数实际上，深拷贝函数是没有实际的应用场景的，但貌似面试的时候面试官比较热衷于问这个问题…(暂时不考虑函数的拷贝用法)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2021-04-19T07:20:36.000Z","updated":"2021-04-19T07:20:37.186Z","comments":true,"path":"2021/04/19/防抖与节流/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/19/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"防抖与节流理解及手写实现","text":"防抖与节流理解及手写实现 在前端开发中，我们会遇到一些频繁的事件触发（滚动条滑动、鼠标事件、搜索框搜索…），如果不加以限制的话，可能会造成浏览器卡顿。为了解决这个问题，出现了两种解决方案： debounce 防抖 throttle 节流 防抖函数定义触发事件n秒后才执行，如果在n秒内重新触发，则重新计时(ps: 有点任性…)。 初版防抖函数 实现思路：通过定时器控制fn是否实现1、每次触发防抖函数时，先清除上一次的定时器，再开启本次触发定时器2、绑定this指向：使用防抖函数后，fn中的this会指向window，要让this指向fn上下文，则需要绑定this指向 -&gt; fn.apply(context)3、绑定event事件：事件处理函数中会提供事件对象event，但是在debounce函数中打印会是undefined，所以需要对event对象特殊处理 -&gt; fn.apply(context, args) 1234567891011function debounce(fn, wait) { var timeout; return function() { var context = this; var args = arguments; clearTimeout(timeout); timeout = setTimeout(function() { fn.apply(context, args); }, wait); }} 防抖函数立即执行在初版防抖函数的基础上，考虑个新需求：我不希望要等到事件停止触发n秒后才执行，我希望它能够立即执行，然后停止触发n秒后才重新触发执行。 12345678910111213141516171819202122function debounce(func, wait, immediate) { var timeout,result; return function() { var context = this; var args = arguments; if(timeout) clearTimeout(timeout); if(immediate) { //如果已经执行过，不再执行 var callNow = !timeout; //定时器结束并设置为null，则可以再次点击执行了 timeout = setTimeout(function() { timeout = null; }, wait); if(callNow) result = func.apply(context, args); } else { timeout = setTimeout(function() { func.apply(context, args); }, wait); } return result; }} 上面代码值得注意的是：func函数是可能有返回值的，所以debounce函数也需要添加返回结果result。当immediate为false时，因为setTimeout函数的存在，return出来的值一直都是undefined，所以我们只需要在immediate为true的时候才添加返回结果。 防抖函数使用场景 避免按钮频繁触发请求 浏览器窗口resize事件 文本编辑器实时保存，无任何操作1s后自动保存 节流函数定义规定时间内只能触发一次时间；如果规定时间内再触发多次，什么都不做。 时间戳版 实现思路:设置时间戳previous开始值为0，当触发事件时，取出当前的时间戳now，减去之前的时间戳previous。如果得到的值大于设置的时间wait，则执行函数func，并更新时间戳previous为当前时间now如果得到的值小于设置时间wait，则什么都不做 123456789101112function throttle(func, wait) { var previous = 0; return function() { var now = +new Date(); var context = this; var args = arguments; if(now - previous &gt; wait) { func.apply(context, args); previous = now; } }} 触发事件会立即执行一次，停止触发事件便不再执行 定时器版 实现思路:当触发事件时，设置一个定时器，再次触发该事件的时候如果定时器存在，就不执行func，直到上一轮定时器执行完并且为null，才会执行func，并清除本次定时器 12345678910111213function throttle(func, wait) { var timeout; return function() { var context = this; var args = arguments; if(!timeout) { timeout = setTimeout(function() { timeout = null; func.apply(context, args); }, wait); } }} 触发事件不会立即执行，n秒后才执行第一次，停止触发事件后还会再执行一次。 双剑合璧版 123456789101112131415161718192021222324252627function throttle(func, wait) { var timeout, context, args; var previous = 0; var later = function() { previous = +new Date(); timeout = null; func.apply(context, args) }; var throttled = function() { var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; func.apply(context, args); } else if (!timeout) { timeout = setTimeout(later, remaining); } }; return throttled;} 节流函数使用场景 scroll滚动事件 浏览器播放 搜索框实时搜索","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"水平垂直居中问题","slug":"水平垂直居中问题","date":"2021-04-15T11:28:04.000Z","updated":"2021-04-15T11:28:04.438Z","comments":true,"path":"2021/04/15/水平垂直居中问题/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/15/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/","excerpt":"css中常用的水平垂直居中记录","text":"css中常用的水平垂直居中记录 项目开发中我们经常会遇到盒子的水平垂直居中问题，定宽高的方式有很多，这里不再记录，主要记录下在不定宽高情况下的实现方式。 下面用到的盒子如下： 123&lt;div class=\"parent\"&gt; &lt;div class=\"son\"&gt;测试水平垂直居中&lt;/div&gt;&lt;/div&gt; flex布局 12345.parent { display: flex; align-items: center; justify-content: center;} flex + margin 123456.parent { display: flex;}.son { margin: auto;} absolute + transform常用于图片的居中显示 123456789.parent { position: relative;}.son { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);} table-cell利用表格布局方式实现 12345.parent { display: table-cell; text-align: center; vertical-align: middle;} grid布局 1234567.parent { display: grid;}.son { align-self: center; justify-self: center;} absolute + 四个方向值相等这种方式需要设置子元素的宽高、并且需要设置”margin: auto” 12345678910111213.parent { position: relative;}.son { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: xxx; height: xxx; margin: auto;} after伪元素子元素display需要设置为”inline-block”才生效 12345678910111213.parent { text-align: center;}.parent::after { content: ''; display: inline-block; vertical-align: middle; height: 100%;}.son { display: inline-block; vertical-align: middle;} before伪元素“font-size: 0” 可以消除标签之间的间隙。 12345678910111213141516.parent { text-align: center; font-size: 0;}.parent::before { content: ''; display: inline-block; vertical-align: middle; height: 100%; font-size: 14px;}.son { display: inline-block; vertical-align: middle; font-size: 14px;}","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Css","slug":"Css","permalink":"https://lry61.cn/Joy-blog/tags/Css/"}]},{"title":"BFC记录","slug":"BFC记录","date":"2021-04-15T07:35:01.000Z","updated":"2021-04-15T07:35:01.828Z","comments":true,"path":"2021/04/15/BFC记录/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/15/BFC%E8%AE%B0%E5%BD%95/","excerpt":"什么是BFC？原理？使用场景？","text":"什么是BFC？原理？使用场景？ 什么是BFC？BFC(Block formatting context)直译为“块级格式化上下文”，它是一个独立的渲染区域，规定了内部如何布局，并且与区域外部毫不相关。 通俗一点，创建了BFC的元素就是个独立的盒子，里面子元素的布局不会影响外面元素。 BCF原理 内部的Box在垂直方向一个接一个的放置。 Box垂直方向距离由margin决定，属于同一个BFC的两个相邻Box的margin会重叠。 每个元素的margin box左边，与包含块border box的左边相接触，即使存在浮动也是如此。 BFC区域不与float box重叠。 BFC里面的子元素不会影响外面的元素。 计算BFC高度时，浮动元素也参与计算。 如何创建BFC满足以下任一条件即可创建BFC: 根元素 float属性不是none position不为static、relative overflow不为visible display为inline-block、table-cell、table-caption、flex、line-flex… BFC使用场景 防止margin重叠 清除内部浮动(解决高度塌陷) 自适应两栏布局","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Css","slug":"Css","permalink":"https://lry61.cn/Joy-blog/tags/Css/"}]},{"title":"call、apply、bind的区别与实现","slug":"call、apply、bind的区别与实现","date":"2021-04-14T07:49:27.000Z","updated":"2021-05-06T01:27:02.976Z","comments":true,"path":"2021/04/14/call、apply、bind的区别与实现/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/14/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"了解call、apply、bind异同及实现原理","text":"了解call、apply、bind异同及实现原理 共同点 call、apply、bind都是函数Function原型链上的方法 都是用来改变函数执行时内部的this指向 都可以接收两个或多个参数，第一个为改变后的this指向，后面为可选参数 区别 call、apply调用会立即返回结果，bind不会立即调用，而是返回一个新函数 call的可选参数为参数列表，apply的可选参数为数组或类数组对象 call语法func.call(thisArg, arg1, arg2, ...) thisArg: 可选。如果为null或undefined，则指向window arg1, arg2,…: 参数列表 使用场景 判断数据类型 Object.prototype.toString.call() 类数组借用数组方法 Array.prototype.push.call()、[].slice.call(arguments) 手写实现call 12345678910111213141516Function.prototype.iCall = function(context) { if(context === null || context === undefined) { // 指定null或undefined的this值指向window context = window; } else { // 值为原始值(number、string、boolean)的this会指向该原始值的实例对象 context = Object(context); } // 函数的this指向隐式绑定到context上 context.fn = this; // 取出执行函数的剩余参数列表 let args = [...arguments].slice(1); let result = context.fn(...args); // 执行函数 delete context.fn; // 删除上下文属性，避免内存泄漏 return result;} apply语法func.apply(thisArg, [arg1, arg2, ...]) thisArg: 可选。如果为null或undefined，则指向window arg1, arg2, …: 数组参数列表 使用场景 获取数组最大最小值 Math.max.apply(Math, arr)、Math.min(Math, arr) 手写实现apply 12345678910111213141516function.prototype.iApply = function(context) { if(context === null || context === undefined) { context = window; } else { context = Object(context); } context.fn = this; let result; if(arguments[1]) { // 判断是否有剩余参数，如果有则带参执行 result = context.fn(...arguments[1]); } else { result = context.fn(); } delete context.fn; return result;} bind语法func.bind(thisArg, arg1, arg2, ...) thisArg: 传递给目标函数的值。 arg1, arg2, …: 参数列表。当目标函数被调用后，放在目标函数参数列表中 使用场景 保存函数参数 来看一个经典的面试题 12345for(var i = 1; i &lt;= 5; i++) { setTimeout(function test() { console.log(i); // 依次输出: 6 6 6 6 6 }, i*1000);} 造成这个现象的原因是在setTimeout异步执行时，i已经变成6了。 如果要让它依次输出1,2,3,4,5，有多种解决办法： 闭包 1234567for(var i = 1; i &lt;= 5; i++) { (function(i) { setTimeout(function() { console.log(i); // 依次输出: 1 2 3 4 5 }, i*1000); }(i))} bind绑定 12345for(var i = 1; i &lt;= 5; i++) { setTimeout(function(i) { console.log(i); // 依次输出: 1 2 3 4 5 }.bind(null, i), i*1000);} 实际上这里也是返回了一个闭包，它保存了函数的this指向，初始参数，每次i的变化都会被bind的闭包存起来。 解决回调函数this丢失 手写实现bind(划重点) 1234567891011121314function.prototype.iBind = function(objThis, ...args) { let thisFn = this; //存储源函数及args let fToBind = function() { // 判断this是否是fToBind实例，即返回的fToBind是否通过new调用 const isNew = this instanceof fToBind; // new调用就绑定到this，否则绑定到传入的objThis上 const context = isNew ? this : Object(objThis); // apply调用源函数绑定this并传参，返回执行结果 return thisFn.apply(context, args); }; // 复制源函数的prototype给fToBind fToBind.prototype = Object.create(thisFn.prototype); return fToBind; // 返回拷贝的函数}","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"JS数据类型与类型判断","slug":"JS数据类型与类型判断","date":"2021-04-12T12:46:32.000Z","updated":"2021-04-14T00:54:51.166Z","comments":true,"path":"2021/04/12/JS数据类型与类型判断/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/","excerpt":"JS数据类型基础知识回顾","text":"JS数据类型基础知识回顾 JS数据类型JavaScript数据类型分为“基本数据类型”和“引用数据类型”。到目前为止，基本数据类型共有7种，引用数据类型1种。 基本数据类型 number string boolean undefined null symbol(唯一标识符) bigint(任意大整数) 基本数据类型的值是不可变的，前面5种类型日常使用的比较频繁，不再过多记录，这里记录下ES6以后新增的symbol与bigint。 symbolsymbol是ES6新增的一种基本数据类型，是一种唯一标识符。 定义: let sml = Symbol('symbol') 特性: 唯一性通过symbol声明的两个变量，即使是同一个值也不相等。 123let sml1 = Symbol('1');let sml2 = Symbol('1');console.log(sml1 === sml2); // false 可访问性symbol声明的变量，无法通过for…in、object.keys()访问 1234567let sml1 = Symbol('1');let obj = { [sml1]: '2'};for(let s in obj) { console.log(obj[s]); // undefined} 常用方法 Object.getOwnPropertySymbols(obj)返回一个数组，成员是当前对象用作属性名的symbol值 1234567let sml1 = Symbol('1');let obj = { [sml1]: '2'};let arr = Object.getOwnPropertySymbols(obj);console.log(arr); // [Symbol(1)]console.log(obj[arr[0]]); // 2 Symbol.for()使相同参数变量的symbol值相等 123let sml1 = Symbol.for('1');let sml2 = Symbol.for('1');console.log(sml1 === sml2); // true Symbol.keyFor()获取参数值 12let sml1 = Symbol.for('1');console.log(Symbol.keyFor(sml1)); // 1 bigint在基本数据类型中，整数通常由number类型表示，但是number类型只能表示某个范围内[-(2^53 - 1) ~ (2^53 - 1)]的整数，超出会失去精度;而bigint则可以表示任意大的整数 使用方法 末尾加 n 构造函数BigInt() 注意 bigint不能与number一起使用 bigint不能与“+”号一起使用 引用数据类型 引用数据类型object的值是可变的，通常赋值的引用类型，其指向相同的堆内存。 object包括了数值Array、函数Function、特殊的正则RegExp和时间Date 类型判断typeoftypeof返回一个表示数据类型的字符串 对于基本数据类型返回相应的数据类型，null除外 12345678typeof 1; // number √typeof '1'; // string √typeof true; // boolean √typeof undefined; //undefined √typeof null; // object ×typeof NaN; // number √(NaN据说是number类型的...好奇.jpg)typeof Symbol(); // symbol √typeof 9007199254740999n; // bigint √ 对于引用数据类型返回object，function除外 1234typeof new Function(); // function √typeof []; // object ×typeof new Date(); // object ×typeof new RegExp(); // object × instanceofinstanceof用来检测构造函数的prototype属性是否出现在某个实例对象的原型链上，存在返回true，否则返回false。instanceof是相对引用类型的，基本数据类型不适用 12345[] instanceof Array; // true √new Date() instanceof Date; // true √'1' instanceof String; // false ×null instanceof null; // 报错，无法检测undefined instanceof undefined; //报错，无法检测 值得注意的是，对象原型链最终都指向了Object，即 Array.prototype._proto_ = Object.prototype。 constructorconstructor与instanceof类似，可能在重写过程中把之前的constructor覆盖掉，导致结果不准确。 Object.prototype.toString.call()最常用最全能的方法。MDN有段描述： 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型 123456789Object.prototype.toString.call('1'); // [object String]Object.prototype.toString.call(1); // [object Number]Object.prototype.toString.call(true); // [object Boolean]Object.prototype.toString.call(undefined); // [object Undefined]Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call(new Function()); // [object Function]Object.prototype.toString.call(new Date()); // [object Date]Object.prototype.toString.call([]); // [object Array]Object.prototype.toString.call(new RegExp()); // [object RegExp]","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Welcome to Dog Lai's Blog","slug":"welcome","date":"2021-04-07T01:13:25.653Z","updated":"2021-04-09T13:27:00.342Z","comments":true,"path":"2021/04/07/welcome/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/07/welcome/","excerpt":"Welcome to Dog Lai’s Blog","text":"Welcome to Dog Lai’s Blog 之前在网上查资料时，经常能看到别人高大上的Blog，脑子里都有个Blog 2.0的想法，刚好这段时间项目期不紧，就想着把之前的Blog升级下，发布一个 Blog 2.0-beat版（花里胡哨的版本） Blog 2.0-beat奇思妙想对我而言，我希望2.0版本的博客不单单只是一个博客，它更像微信一样，是一个小型社交平台。我不仅可以在这里记录项目中遇到的问题难点，还能够分享生活中的点点滴滴，与别人交流、发朋友圈、上传相册、放置简历…正如我想的那样，2.0-beat coming！ artitalk 圈子对我而言，有时候想在朋友圈发一些自己的想法有诸多不便，我迫切的需要一个平台表达我的某些想法意见；基于此，artitalk 圈子运营而生，它满足我目前的所有幻想，感情树洞、idea…对我意义重大! photos 相册我希望可以将自己的相册移植到博客中，正好gitHub仓库可以作为图床使用。 我希望后面可以使用时间线来布局我的相册，并且能够配上简短的文字说明这在后面会慢慢考虑功能的实现 写在最后如果你喜欢我的博客，请给我个Star吧~ 欢迎留言欢迎技术交流欢迎谈论博客优化 感谢你的阅读 Thanks♪(･ω･)ﾉ","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://lry61.cn/Joy-blog/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Css","slug":"Css","permalink":"https://lry61.cn/Joy-blog/tags/Css/"}]}
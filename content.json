{"meta":{"title":"Dog Lai's Blog","subtitle":"Front-end development engineer","description":"Author:Dog Lai,Category:Personal Blog","author":"Dog Lai","url":"https://lry61.cn/Joy-blog","root":"/Joy-blog/"},"pages":[{"title":"","date":"2021-04-07T02:49:18.000Z","updated":"2021-04-07T08:34:19.124Z","comments":false,"path":"about/index.html","permalink":"https://lry61.cn/Joy-blog/about/index.html","excerpt":"","text":""},{"title":"artitalk","date":"2021-04-08T08:59:11.000Z","updated":"2021-04-08T09:01:01.329Z","comments":false,"path":"artitalk/index.html","permalink":"https://lry61.cn/Joy-blog/artitalk/index.html","excerpt":"","text":""},{"title":"photos","date":"2021-04-09T07:09:41.000Z","updated":"2021-04-09T08:13:24.384Z","comments":false,"path":"photos/index.html","permalink":"https://lry61.cn/Joy-blog/photos/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-07T02:47:50.000Z","updated":"2021-04-07T08:34:15.920Z","comments":false,"path":"tags/index.html","permalink":"https://lry61.cn/Joy-blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2021-04-21T08:40:03.000Z","updated":"2021-04-21T08:40:04.190Z","comments":true,"path":"2021/04/21/深拷贝与浅拷贝/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"深浅拷贝的理解与实现","text":"深浅拷贝的理解与实现 概念 浅拷贝是创建一个新的对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。如果其中一个对象改变了这个地址，就会影响到另一个对象。 借用conardLi大佬的图片加以理解: 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象。修改新对象不会影响原对象。 在深入了解深拷贝与浅拷贝之前，我们简单回顾下堆栈和JavaScript数据类型 JavaScript数据类型JavaScript数据类型分为两种: 基本数据类型(number、string、boolean、undefined、null、symbol、bigint) 基本数据类型可以直接访问，它们是按值分配的，存放在栈(stack)内存中的简单数据段，数据大小确定，内存空间大小可分配。基本数据类型的复制，会在栈内存中开辟一个新的空间，单独修改变量不会相互影响。 引用数据类型(object -&gt; Array、Function、Date、RegExp) 存放在堆(heap)内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。引用类型的复制，也会为新变量自动分配一个栈内存空间，但是保存的只是引用类型的一个指针。当指针地址相同时，访问到的堆内存中的具体对象实际是同一个，当改变一个时，另一个也跟着改变。 堆与栈在计算机领域中，堆和栈是两种数据结构。 栈(stack) 自动分配内存空间，会自动释放 存放基本数据类型的值、引用类型的地址(即对象的引用)，按值访问、先进后出 动态分配的空间一般由程序员分配释放；若程序员不释放，则程序结束时由OS回收 对象复制的时候，复制的是栈中的地址而不是堆中的对象，两个地址指向同一个对象 堆(heap) 动态分配内存，大小不定，不会自动释放 存放引用数据类型的对象值、函数的参数值、局部变量的值等，队列优先、先进先出 引用数据类型的值是保存在堆内存中的对象，JavaScript不允许直接访问堆内存中的位置 不能直接操作对象的堆内存空间。操作对象时，实际操作的是对象的引用而不是对象本身 我们以一个简单的赋值例子来看下: 12345678let a = 1;let b = a;a = 2;console.log(a, b); // 2 1let c = {name: \"Dog Lai\"};d = c;d.name = \"lry\";console.log(c, d); // {name: \"lry\"} {name: \"lry\"} 根据上面的例子，在变量还未变化时，有如下堆栈图: 当对一个变量进行赋值时，都会在栈内存中开辟一个新的内存空间。但对于基本数据类型而言，新的内存空间存的是数据本身，不会相互影响；对于引用数据类型而言，内存空间存的是一个地址指针(对象的引用)，指向堆内存中的实际对象数据。由此可见，深浅拷贝是相对于引用数据类型而言的 赋值与浅拷贝我们看下面一个例子，比较赋值与浅拷贝会对对象带来哪些改变 对象赋值: 12345678910let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"game\", \"basketball\"]};let obj2 = obj1;obj2.name = \"LRY0504\";obj2.hobby[0] = \"book\";console.log(obj1);console.log(obj2); 上面例子运行后，结果如下: 赋值操作 浅拷贝: 12345678910111213141516171819let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"game\", \"basketball\"]};let obj2 = shallowClone(obj1);obj2.name = \"LRY0504\";obj2.hobby[0] = \"book\";function shallowClone(obj) { let res = {}; for(const key in obj) { if(obj.hasOwnProperty(key)) { res[key] = obj[key]; } } return res;}console.log(obj1);console.log(obj2); 上面函数shallowClone是一个简单的浅拷贝实现方式，运行结果如下: 浅拷贝 对比上面两个例子可以看出: 所谓“赋值”，其实是该对象在栈中的地址，而非堆中的数据。即两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实改变的都是存储空间的内容，另一个对象也会跟着改变。 浅拷贝会创建一个新对象，这个对象有着原始对象的一份精确拷贝。如果数据属性是基本数据类型，拷贝的是基本类型的值；如果是引用数据类型，拷贝的就是内存地址。如果一个对象改变了这个地址，就会影响到另一个对象。 浅拷贝的实现Object.assign与展开运算符…Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 1234567891011121314151617let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"basketball\", \"game\"], data: { name: \"试题信息\", quesList: [1, 2, [3, 4]] }};let obj2 = Object.assign({}, obj1);obj2.name=\"LRY0504\";obj2.hobby[0] = \"book\";obj2.data.name = \"试题列表\";obj2.data.quesList[0] = 5;obj2.data.quesList[2][0] = 6;console.log(obj1);console.log(obj2); 运行上面代码，结果如下: 从结果中可以看出：使用Object.assign()拷贝过的对象，第一层数据并没有随着obj2的改变而改变，第二层及更深层级的数据随着obj2的改变而改变。由此可以得出以下结论:Object.assign()第一层是深拷贝，第二层及更深层是浅拷贝展开运算符… 与Object.assign()功能一致，不再具体说明 concat与sliceconcat与slice都是相对Array层面的浅拷贝 123456789101112131415161718let obj1 = [{ name: \"lry\", age: 24, hobby: [\"music\", \"basketball\", \"game\"], data: { name: \"试题信息\", quesList: [1, 2, [3, 4]] }}];let obj2 = obj1.concat();// 或者 let obj2 = obj1.slice();obj2[0].name=\"LRY0504\";obj2[0].hobby[0] = \"book\";obj2[0].data.name = \"试题列表\";obj2[0].data.quesList[0] = 5;obj2[0].data.quesList[2][0] = 6;console.log(obj1);console.log(obj2); 运行上面代码，结果如下: 深拷贝的实现JSON.parse(JSON.stringify())一说到深拷贝，第一个想到的估计就是这个方法了。这种方法虽然可以实现数组或对象的深拷贝，但不能处理函数和正则。 RegExp -&gt;-&gt;- JSON.parse(JSON.stringify()) -&gt;-&gt;- &gt;&gt;&gt; {}Function -&gt;-&gt;- JSON.parse(JSON.stringify()) -&gt;-&gt;- &gt;&gt;&gt; null 迭代递归法 实现原理:遍历对象或数组，直到里面都是基本数据类型，然后再去复制，就是深度拷贝 1234567891011121314151617181920212223242526272829303132function isObject(o) { return (typeof o === \"object\" || typeof o === \"function\") &amp;&amp; o !== null;}function deepClone(obj) { if(!isObject(obj)) { return obj; } let cloneObj = Array.isArray(obj) ? [] : {}; for(let key in obj) { cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]; } return cloneObj;}let obj1 = { name: \"lry\", age: 24, hobby: [\"music\", \"basketball\", \"game\"], data: { name: \"试题信息\", quesList: [1, 2, [3, 4]] }};let obj2 = deepClone(obj1);obj2.name = \"LRY0504\";obj2.hobby[0] = \"book\";obj2.data.name = \"试题列表\";obj2.data.quesList[0] = 5;obj2.data.quesList[2][0] = 6;console.log(obj1);console.log(obj2); 运行上面代码，结果如下: 关于深拷贝的思考上面的迭代递归法基本满足深拷贝的应用场景，但无法支持Date、RegExp、symbol、function数据类型 支持Date数据在判断是否是对象后面，加入下面代码: 1if (obj instanceof Date) return new Date(obj); 支持正则RegExp同样在判断Date后面加上以下代码: 1if (obj instanceof RegExp) return new RegExp(obj); 支持symbol在正则RegExp判断后面加上以下代码: 123if(obj instanceof Symbol) { return Object(Symbol.prototype.ValueOf.call(obj));} 关于function函数实际上，深拷贝函数是没有实际的应用场景的，但貌似面试的时候面试官比较热衷于问这个问题…(暂时不考虑函数的拷贝用法)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2021-04-19T07:20:36.000Z","updated":"2021-04-19T07:20:37.186Z","comments":true,"path":"2021/04/19/防抖与节流/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/19/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"防抖与节流理解及手写实现","text":"防抖与节流理解及手写实现 在前端开发中，我们会遇到一些频繁的事件触发（滚动条滑动、鼠标事件、搜索框搜索…），如果不加以限制的话，可能会造成浏览器卡顿。为了解决这个问题，出现了两种解决方案： debounce 防抖 throttle 节流 防抖函数定义触发事件n秒后才执行，如果在n秒内重新触发，则重新计时(ps: 有点任性…)。 初版防抖函数 实现思路：通过定时器控制fn是否实现1、每次触发防抖函数时，先清除上一次的定时器，再开启本次触发定时器2、绑定this指向：使用防抖函数后，fn中的this会指向window，要让this指向fn上下文，则需要绑定this指向 -&gt; fn.apply(context)3、绑定event事件：事件处理函数中会提供事件对象event，但是在debounce函数中打印会是undefined，所以需要对event对象特殊处理 -&gt; fn.apply(context, args) 1234567891011function debounce(fn, wait) { var timeout; return function() { var context = this; var args = arguments; clearTimeout(timeout); timeout = setTimeout(function() { fn.apply(context, args); }, wait); }} 防抖函数立即执行在初版防抖函数的基础上，考虑个新需求：我不希望要等到事件停止触发n秒后才执行，我希望它能够立即执行，然后停止触发n秒后才重新触发执行。 12345678910111213141516171819202122function debounce(func, wait, immediate) { var timeout,result; return function() { var context = this; var args = arguments; if(timeout) clearTimeout(timeout); if(immediate) { //如果已经执行过，不再执行 var callNow = !timeout; //定时器结束并设置为null，则可以再次点击执行了 timeout = setTimeout(function() { timeout = null; }, wait); if(callNow) result = func.apply(context, args); } else { timeout = setTimeout(function() { func.apply(context, args); }, wait); } return result; }} 上面代码值得注意的是：func函数是可能有返回值的，所以debounce函数也需要添加返回结果result。当immediate为false时，因为setTimeout函数的存在，return出来的值一直都是undefined，所以我们只需要在immediate为true的时候才添加返回结果。 防抖函数使用场景 避免按钮频繁触发请求 浏览器窗口resize事件 文本编辑器实时保存，无任何操作1s后自动保存 节流函数定义规定时间内只能触发一次时间；如果规定时间内再触发多次，什么都不做。 时间戳版 实现思路:设置时间戳previous开始值为0，当触发事件时，取出当前的时间戳now，减去之前的时间戳previous。如果得到的值大于设置的时间wait，则执行函数func，并更新时间戳previous为当前时间now如果得到的值小于设置时间wait，则什么都不做 123456789101112function throttle(func, wait) { var previous = 0; return function() { var now = +new Date(); var context = this; var args = arguments; if(now - previous &gt; wait) { func.apply(context, args); previous = now; } }} 触发事件会立即执行一次，停止触发事件便不再执行 定时器版 实现思路:当触发事件时，设置一个定时器，再次触发该事件的时候如果定时器存在，就不执行func，直到上一轮定时器执行完并且为null，才会执行func，并清除本次定时器 12345678910111213function throttle(func, wait) { var timeout; return function() { var context = this; var args = arguments; if(!timeout) { timeout = setTimeout(function() { timeout = null; func.apply(context, args); }, wait); } }} 触发事件不会立即执行，n秒后才执行第一次，停止触发事件后还会再执行一次。 双剑合璧版 123456789101112131415161718192021222324252627function throttle(func, wait) { var timeout, context, args; var previous = 0; var later = function() { previous = +new Date(); timeout = null; func.apply(context, args) }; var throttled = function() { var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; func.apply(context, args); } else if (!timeout) { timeout = setTimeout(later, remaining); } }; return throttled;} 节流函数使用场景 scroll滚动事件 浏览器播放 搜索框实时搜索","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"水平垂直居中问题","slug":"水平垂直居中问题","date":"2021-04-15T11:28:04.000Z","updated":"2021-04-15T11:28:04.438Z","comments":true,"path":"2021/04/15/水平垂直居中问题/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/15/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/","excerpt":"css中常用的水平垂直居中记录","text":"css中常用的水平垂直居中记录 项目开发中我们经常会遇到盒子的水平垂直居中问题，定宽高的方式有很多，这里不再记录，主要记录下在不定宽高情况下的实现方式。 下面用到的盒子如下： 123&lt;div class=\"parent\"&gt; &lt;div class=\"son\"&gt;测试水平垂直居中&lt;/div&gt;&lt;/div&gt; flex布局 12345.parent { display: flex; align-items: center; justify-content: center;} flex + margin 123456.parent { display: flex;}.son { margin: auto;} absolute + transform常用于图片的居中显示 123456789.parent { position: relative;}.son { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);} table-cell利用表格布局方式实现 12345.parent { display: table-cell; text-align: center; vertical-align: middle;} grid布局 1234567.parent { display: grid;}.son { align-self: center; justify-self: center;} absolute + 四个方向值相等这种方式需要设置子元素的宽高、并且需要设置”margin: auto” 12345678910111213.parent { position: relative;}.son { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: xxx; height: xxx; margin: auto;} after伪元素子元素display需要设置为”inline-block”才生效 12345678910111213.parent { text-align: center;}.parent::after { content: ''; display: inline-block; vertical-align: middle; height: 100%;}.son { display: inline-block; vertical-align: middle;} before伪元素“font-size: 0” 可以消除标签之间的间隙。 12345678910111213141516.parent { text-align: center; font-size: 0;}.parent::before { content: ''; display: inline-block; vertical-align: middle; height: 100%; font-size: 14px;}.son { display: inline-block; vertical-align: middle; font-size: 14px;}","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Css","slug":"Css","permalink":"https://lry61.cn/Joy-blog/tags/Css/"}]},{"title":"BFC记录","slug":"BFC记录","date":"2021-04-15T07:35:01.000Z","updated":"2021-04-15T07:35:01.828Z","comments":true,"path":"2021/04/15/BFC记录/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/15/BFC%E8%AE%B0%E5%BD%95/","excerpt":"什么是BFC？原理？使用场景？","text":"什么是BFC？原理？使用场景？ 什么是BFC？BFC(Block formatting context)直译为“块级格式化上下文”，它是一个独立的渲染区域，规定了内部如何布局，并且与区域外部毫不相关。 通俗一点，创建了BFC的元素就是个独立的盒子，里面子元素的布局不会影响外面元素。 BCF原理 内部的Box在垂直方向一个接一个的放置。 Box垂直方向距离由margin决定，属于同一个BFC的两个相邻Box的margin会重叠。 每个元素的margin box左边，与包含块border box的左边相接触，即使存在浮动也是如此。 BFC区域不与float box重叠。 BFC里面的子元素不会影响外面的元素。 计算BFC高度时，浮动元素也参与计算。 如何创建BFC满足以下任一条件即可创建BFC: 根元素 float属性不是none position不为static、relative overflow不为visible display为inline-block、table-cell、table-caption、flex、line-flex… BFC使用场景 防止margin重叠 清除内部浮动(解决高度塌陷) 自适应两栏布局","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Css","slug":"Css","permalink":"https://lry61.cn/Joy-blog/tags/Css/"}]},{"title":"call、apply、bind的区别与实现","slug":"call、apply、bind的区别与实现","date":"2021-04-14T07:49:27.000Z","updated":"2021-04-14T07:49:27.700Z","comments":true,"path":"2021/04/14/call、apply、bind的区别与实现/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/14/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"了解call、apply、bind异同及实现原理","text":"了解call、apply、bind异同及实现原理 共同点 call、apply、bind都是函数Function原型链上的方法 都是用来改变函数执行时内部的this指向 都可以接收两个或多个参数，第一个为改变后的this指向，后面为可选参数 区别 call、apply调用会立即返回结果，bind不会立即调用，而是返回一个新函数 call的可选参数为参数列表，apply的可选参数为数组或类数组对象 call语法func.call(thisArg, arg1, arg2, ...) thisArg: 可选。如果为null或undefined，则指向window arg1, arg2,…: 参数列表 使用场景 判断数据类型 Object.prototype.toString.call() 类数组借用数组方法 Array.prototype.push.call()、[].slice.call(arguments) 手写实现call 12345678910111213141516Function.prototype.iCall = function(context) { if(context === null || context === undefined) { // 指定null或undefined的this值指向window context = window; } else { // 值为原始值(number、string、boolean)的this会指向该原始值的实例对象 context = Object(context); } // 函数的this指向隐式绑定到context上 context.fn = this; // 取出执行函数的剩余参数列表 let args = [...arguments].slice(1); let result = context.fn(...args); // 执行函数 delete context.fn; // 删除上下文属性，避免内存泄漏 return result;} apply语法func.apply(thisArg, [arg1, arg2, ...]) thisArg: 可选。如果为null或undefined，则指向window arg1, arg2, …: 数组参数列表 使用场景 获取数组最大最小值 Math.max.apply(Math, arr)、Math.min(Math, arr) 手写实现apply 12345678910111213141516function.prototype.iApply = function(context) { if(context === null || context === undefined) { context = window; } else { context = Object(context); } context.fn = this; let result; if(arguments[1]) { // 判断是否有剩余参数，如果有则带参执行 result = context.fn(...arguments[1]); } else { result = context.fn(); } delete context.fn; return result;} bind语法func.bind(thisArg, arg1, arg2, ...) thisArg: 传递给目标函数的值。 arg1, arg2, …: 参数列表。当目标函数被调用后，放在目标函数参数列表中 使用场景 保存函数参数 来看一个经典的面试题 12345for(var i = 1; i &lt;= 5; i++) { setTimeout(function test() { console.log(i); // 依次输出: 6 6 6 6 6 }, i*1000);} 造成这个现象的原因是在setTimeout异步执行时，i已经变成6了。 如果要让它依次输出1,2,3,4,5，有多种解决办法： 闭包 1234567for(var i = 1; i &lt;= 5; i++) { (function(i) { setTimeout(function() { console.log(i); // 依次输出: 1 2 3 4 5 }, i*1000); }(i))} bind绑定 12345for(var i = 1; i &lt;= 5; i++) { setTimeout(function(i) { console.log(i); // 依次输出: 1 2 3 4 5 }.bind(null, i), i*1000);} 实际上这里也是返回了一个闭包，它保存了函数的this指向，初始参数，每次i的变化都会被bind的闭包存起来。 解决回调函数this丢失 手写实现bind(划重点) 1234567891011121314function.prototype.iBind = function(objThis, ...args) { let thisFn = this; //存储源函数及args let fToBind = function() { // 判断this是否是fToBind实例，即返回的fToBind是否通过new调用 const isNew = this instanceof fToBind; // new调用就绑定到this，否则绑定到传入的objThis上 const context = isNew ? this : Object(objThis); // apply调用源函数绑定this并传参，返回执行结果 return thisFn.apply(context, args); }; // 复制源函数的prototype给fToBind fToBind.prototype = Object.create(thisFn.prototype); return fToBind; // 返回拷贝的函数}","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"JS数据类型与类型判断","slug":"JS数据类型与类型判断","date":"2021-04-12T12:46:32.000Z","updated":"2021-04-14T00:54:51.166Z","comments":true,"path":"2021/04/12/JS数据类型与类型判断/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/12/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/","excerpt":"JS数据类型基础知识回顾","text":"JS数据类型基础知识回顾 JS数据类型JavaScript数据类型分为“基本数据类型”和“引用数据类型”。到目前为止，基本数据类型共有7种，引用数据类型1种。 基本数据类型 number string boolean undefined null symbol(唯一标识符) bigint(任意大整数) 基本数据类型的值是不可变的，前面5种类型日常使用的比较频繁，不再过多记录，这里记录下ES6以后新增的symbol与bigint。 symbolsymbol是ES6新增的一种基本数据类型，是一种唯一标识符。 定义: let sml = Symbol('symbol') 特性: 唯一性通过symbol声明的两个变量，即使是同一个值也不相等。 123let sml1 = Symbol('1');let sml2 = Symbol('1');console.log(sml1 === sml2); // false 可访问性symbol声明的变量，无法通过for…in、object.keys()访问 1234567let sml1 = Symbol('1');let obj = { [sml1]: '2'};for(let s in obj) { console.log(obj[s]); // undefined} 常用方法 Object.getOwnPropertySymbols(obj)返回一个数组，成员是当前对象用作属性名的symbol值 1234567let sml1 = Symbol('1');let obj = { [sml1]: '2'};let arr = Object.getOwnPropertySymbols(obj);console.log(arr); // [Symbol(1)]console.log(obj[arr[0]]); // 2 Symbol.for()使相同参数变量的symbol值相等 123let sml1 = Symbol.for('1');let sml2 = Symbol.for('1');console.log(sml1 === sml2); // true Symbol.keyFor()获取参数值 12let sml1 = Symbol.for('1');console.log(Symbol.keyFor(sml1)); // 1 bigint在基本数据类型中，整数通常由number类型表示，但是number类型只能表示某个范围内[-(2^53 - 1) ~ (2^53 - 1)]的整数，超出会失去精度;而bigint则可以表示任意大的整数 使用方法 末尾加 n 构造函数BigInt() 注意 bigint不能与number一起使用 bigint不能与“+”号一起使用 引用数据类型 引用数据类型object的值是可变的，通常赋值的引用类型，其指向相同的堆内存。 object包括了数值Array、函数Function、特殊的正则RegExp和时间Date 类型判断typeoftypeof返回一个表示数据类型的字符串 对于基本数据类型返回相应的数据类型，null除外 12345678typeof 1; // number √typeof '1'; // string √typeof true; // boolean √typeof undefined; //undefined √typeof null; // object ×typeof NaN; // number √(NaN据说是number类型的...好奇.jpg)typeof Symbol(); // symbol √typeof 9007199254740999n; // bigint √ 对于引用数据类型返回object，function除外 1234typeof new Function(); // function √typeof []; // object ×typeof new Date(); // object ×typeof new RegExp(); // object × instanceofinstanceof用来检测构造函数的prototype属性是否出现在某个实例对象的原型链上，存在返回true，否则返回false。instanceof是相对引用类型的，基本数据类型不适用 12345[] instanceof Array; // true √new Date() instanceof Date; // true √'1' instanceof String; // false ×null instanceof null; // 报错，无法检测undefined instanceof undefined; //报错，无法检测 值得注意的是，对象原型链最终都指向了Object，即 Array.prototype._proto_ = Object.prototype。 constructorconstructor与instanceof类似，可能在重写过程中把之前的constructor覆盖掉，导致结果不准确。 Object.prototype.toString.call()最常用最全能的方法。MDN有段描述： 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型 123456789Object.prototype.toString.call('1'); // [object String]Object.prototype.toString.call(1); // [object Number]Object.prototype.toString.call(true); // [object Boolean]Object.prototype.toString.call(undefined); // [object Undefined]Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call(new Function()); // [object Function]Object.prototype.toString.call(new Date()); // [object Date]Object.prototype.toString.call([]); // [object Array]Object.prototype.toString.call(new RegExp()); // [object RegExp]","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Welcome to Dog Lai's Blog","slug":"welcome","date":"2021-04-07T01:13:25.653Z","updated":"2021-04-09T13:27:00.342Z","comments":true,"path":"2021/04/07/welcome/","link":"","permalink":"https://lry61.cn/Joy-blog/2021/04/07/welcome/","excerpt":"Welcome to Dog Lai’s Blog","text":"Welcome to Dog Lai’s Blog 之前在网上查资料时，经常能看到别人高大上的Blog，脑子里都有个Blog 2.0的想法，刚好这段时间项目期不紧，就想着把之前的Blog升级下，发布一个 Blog 2.0-beat版（花里胡哨的版本） Blog 2.0-beat奇思妙想对我而言，我希望2.0版本的博客不单单只是一个博客，它更像微信一样，是一个小型社交平台。我不仅可以在这里记录项目中遇到的问题难点，还能够分享生活中的点点滴滴，与别人交流、发朋友圈、上传相册、放置简历…正如我想的那样，2.0-beat coming！ artitalk 圈子对我而言，有时候想在朋友圈发一些自己的想法有诸多不便，我迫切的需要一个平台表达我的某些想法意见；基于此，artitalk 圈子运营而生，它满足我目前的所有幻想，感情树洞、idea…对我意义重大! photos 相册我希望可以将自己的相册移植到博客中，正好gitHub仓库可以作为图床使用。 我希望后面可以使用时间线来布局我的相册，并且能够配上简短的文字说明这在后面会慢慢考虑功能的实现 写在最后如果你喜欢我的博客，请给我个Star吧~ 欢迎留言欢迎技术交流欢迎谈论博客优化 感谢你的阅读 Thanks♪(･ω･)ﾉ","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lry61.cn/Joy-blog/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"https://lry61.cn/Joy-blog/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Css","slug":"Css","permalink":"https://lry61.cn/Joy-blog/tags/Css/"}]}